<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/17/API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godzhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/17/API/" itemprop="url">Javascript API</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-17T00:22:01+08:00">
                2017-09-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h3 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h3><ul>
<li>nodeName</li>
<li>nodeValue</li>
<li>childNodes<ul>
<li>保存nodeList对象</li>
<li>有length属性</li>
<li>访问：childNodes[0],childNodes.item(0)</li>
</ul>
</li>
<li>parentNode：父节点</li>
<li>previousSibling：上一个同胞节点，第一个节点的previousSibling为null</li>
<li>nextSibling：下一个同胞节点，最后一个节点的nextSibling为null</li>
<li>firstChild：第一个子节点, parentNode.childNodes[0]</li>
<li>lastChild：最后一个子节点, parentNode.childNodes[parentNode.length - 1]</li>
<li>ownerDocument：指向整个文档的文档节点——document(文档元素<html>)</html></li>
<li>document.documentElement：始终指向<html>元素</html></li>
<li>document.body：指向body元素</li>
<li>document.doctype：指向&lt;!DOCTYPE&gt;，兼容性差，用处小(一下属性在&lt;!doctype html&gt;下)<ul>
<li>publicId：信息段(空)</li>
<li>systemId：信息段(空)</li>
<li>internalSubset：用于访问包含在文档类型声明中的额外定义(undefined)</li>
</ul>
</li>
<li>document.title: (rw)</li>
<li>document.URL：页面完整的url(r)</li>
<li>document.domain：页面的域名(rw)</li>
<li>document.referrer：链接到当前页面的页面url(r)</li>
<li>document.anchors：所有带name的a元素</li>
<li>document.forms</li>
<li>document.images</li>
<li>document.links：所有带href的a元素</li>
<li>document.implementation<ul>
<li>hasFeatrue(DOMname, version)：检测是否支持DOM功能</li>
<li>createDocumentType(name, publicId, systemId)：创建一个新的DocumentType节点</li>
<li>createDocument(namespaceURI, 文档元素, 文档类型)：创建新文档</li>
<li>createHTMLDocument(title)：创建一个完整的html文档</li>
</ul>
</li>
<li>HTML元素属性<ul>
<li>id</li>
<li>title</li>
<li>lang</li>
<li>dir</li>
<li>className</li>
</ul>
</li>
<li>attributes属性(NamedNodeMap)<ul>
<li>getNamedItem(name)       返回nodeName属性等于name的节点</li>
<li>removeNamedItem(name) </li>
<li>setNamedItem(node)       向列表中添加节点，以节点的nodeName属性为索引</li>
<li>item(pos)</li>
</ul>
</li>
<li>specified：未设置过特性的为false(element.attributes[i].specified)</li>
<li>text.data == text.nodeValue</li>
<li>不会返回空白文本节点的属性(IE9+)<ul>
<li>childElementCount：子元素个数</li>
<li>firstElementChild</li>
<li>lastElementChild</li>
<li>previousElementSibling</li>
<li>nextElementSibling</li>
</ul>
</li>
<li>classList：(DOMTokenList实例)<ul>
<li>add(value)</li>
<li>contains(value)</li>
<li>remove(value)</li>
<li>toggle(value)</li>
</ul>
</li>
<li>document.activeElement：始终引用DOM中获得了焦点的元素</li>
<li>document.readyState：下面两种状态<ul>
<li>loading</li>
<li>complete</li>
</ul>
</li>
<li>document.compatMode：告诉采用了哪种渲染模式<ul>
<li>标准模式: “CSS1Compat”</li>
<li>混杂模式: “BackCompat”</li>
</ul>
</li>
<li>document.head -&gt; <head></head></li>
<li>document.charset：字符集属性，可读写(经测试，IE可以改写,firefox,chrome无效)</li>
<li>document.defaultCharset：默认浏览器和操作系统的设置(经测试，IE可以,firefox,chrome返回undefined)</li>
<li>自定义数据属性<ul>
<li>dataset：DOMStringMap实例</li>
</ul>
</li>
<li>innerHTML</li>
<li>outerHTML</li>
<li>document.documentMode：返回使用的文档模式，IE属性</li>
<li>children：只返回元素节点，不包括空白节点</li>
<li>innerText：火狐中是textContent属性(经测试，两个属性所有IE5+,chrome等都支持)</li>
<li>outerText</li>
<li>document.defaultView：指向拥有给定文档的窗口(IE9+)(IE中为parentWindow属性,经测试:document.parentWindow !== window)</li>
<li>框架属性<ul>
<li>contentDocument：指向框架的文档对象</li>
<li>contentWindow：(全部支持)iframe.contentWindow.document === iframe.contentDocument</li>
</ul>
</li>
<li>element.style<ul>
<li>访问样式使用驼峰写法,访问float分别是cssFloat || styleFloat</li>
<li>cssText</li>
<li>length</li>
<li>parentRule</li>
<li>getPropertyCSSValue(propertyName)：IE,chrome不支持,firefox总返回null</li>
<li>getPropertyPriority(propertyName)</li>
<li>getPropertyValue(propertyName)</li>
<li>item(index)</li>
<li>removeProperty(propertyName)</li>
<li>setProperty(propertyName,value,priority)</li>
</ul>
</li>
<li>document.defaultView.getComputedStyle(attrName, :after) === window.getComputedStyle(attrName, :after)</li>
</ul>
<h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><ul>
<li>hasChildNodes()：判断有没有子节点</li>
<li>appendChild()：返回新增的节点</li>
<li>insertBefore(currentNode,insertNode)：返回被插入的节点<ul>
<li>insertBefore(null, insertNode) =&gt; appendChild(insertNode)</li>
</ul>
</li>
<li>replaceChild(insertNode, replaceNode)：返回要替换的节点</li>
<li>removeChild()：返回移除的节点</li>
<li>cloneNode(deep):deep表示是否深复制</li>
<li>normalize()：合并相邻的文本节点</li>
<li>document.getElementById()</li>
<li>document.getElementsByTagName()<ul>
<li>namedItem()：通过元素的name特性取得集合中的项,只取一项</li>
</ul>
</li>
<li>document.getElementsByName()</li>
<li>document.write()</li>
<li>document.writeln()：末尾会添加换行符”\n”</li>
<li>document.open()</li>
<li>document.close()</li>
<li>getAttribute(attr)</li>
<li>setAttribute(attr, attrName)</li>
<li>removeAttribute(attr)</li>
<li>document.createElement()</li>
<li>text：(文本节点操作方法)<ul>
<li>appendData(text)</li>
<li>deleteData(offset, count)</li>
<li>insertData(offset, text)</li>
<li>replaceData(offset, count, text)</li>
<li>splitText(offset)</li>
<li>substringData(offset, count)</li>
</ul>
</li>
<li>document.createTextNode(text)</li>
<li>document.createDocumentFragment()</li>
<li>document.createAttribute()：创建属性节点</li>
<li>setAttributeNode()：设置属性</li>
<li>getAttributeNode()：与attributes返回值相同</li>
<li>querySelector()</li>
<li>querySelectorAll()</li>
<li>matchesSelector(cssSelector)：判断调用元素与该选择符是否匹配<ul>
<li>msMatchesSelector</li>
<li>mozMatchesSelector</li>
<li>webkitMatchesSelector</li>
</ul>
</li>
<li>document.getElementsByClassName()(IE9+)</li>
<li>document.hasFocus()</li>
<li>window.toStaticHTML()：返回一个处理后的html片段,从源html删除脚本节点和事件处理程序,(经测试，IE所有版本都支持，但无效)</li>
<li>insertAdjacentHTML(insertPos, htmlText)<ul>
<li>insertPos<ul>
<li>beforebegin</li>
<li>afterbegin</li>
<li>beforeend</li>
<li>afterend</li>
</ul>
</li>
</ul>
</li>
<li>scrollIntoView(bol)<ul>
<li>bol<ul>
<li>true：默认值，让元素顶部与页面顶部对齐</li>
<li>false：让元素底部与页面底部对齐</li>
</ul>
</li>
</ul>
</li>
<li>contains()：检测某个节点是不是另一个节点的后代</li>
<li>compareDocumentPosition()：确定两个节点的位置关系<ul>
<li>1：无关</li>
<li>2：居前</li>
<li>4：居后</li>
<li>8：包含</li>
<li>16：被包含</li>
</ul>
</li>
<li>滚动相关的几个方法(仅chrome支持)<ul>
<li>scrollIntoViewIfNeeded(alignCenter)：只在元素不可见时才滚动(chrome支持)</li>
<li>scrollByLines(lineCount)：将元素内容滚动指定行高(chrome已不支持)</li>
<li>scrollByPages(pageCount)：将元素内容滚动指定页面高度(chrome已不支持)</li>
</ul>
</li>
<li>importNode(node, deep)：从一个文档中取得一个节点，导入到另一个文档,与cloneNode方法类似(IE9+)</li>
<li>isSupported(name, version)：确定当前节点具有什么能力(firefox,chrome不支持,IE9+支持)</li>
<li>isSameNode()：判断传入节点和引用节点是否相同</li>
<li>isEqualNode()：判断传入节点和引用节点是否相等</li>
<li>setUserData(要设置的键,实际数据,处理函数)：经测试,chrome,firefox,IE都不支持</li>
<li>getUserDate(键名)：经测试,chrome,firefox,IE都不支持</li>
</ul>
<h3 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h3><ul>
<li>nodeType: 9</li>
<li>nodeName: “#document”</li>
<li>nodeValue: null</li>
<li>parentNode: null</li>
<li>ownerDocument: null</li>
</ul>
<h3 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h3><ul>
<li>nodeType: 1</li>
<li>nodeName: tagName</li>
<li>nodeValue: null</li>
</ul>
<h3 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h3><ul>
<li>nodeType: 3</li>
<li>nodeName: “#text”</li>
<li>nodeValue: 文本内容</li>
<li>没有子节点</li>
</ul>
<h3 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h3><ul>
<li>nodeType: 8</li>
<li>nodeName: “#comment”</li>
<li>nodeValue: 注释的内容</li>
<li>没有子节点</li>
<li>它与Text类型继承自相同的基类，拥有除splitText()之外所有字符串操作方法</li>
</ul>
<h3 id="CDATASection类型"><a href="#CDATASection类型" class="headerlink" title="CDATASection类型"></a>CDATASection类型</h3><ul>
<li>nodeType: 4</li>
<li>nodeName: “#cdata-section”</li>
<li>nodeValue: 对应内容</li>
<li>没有子节点</li>
<li>XML文档中，用document.createCDataSection()常见CDATA区域</li>
</ul>
<h3 id="DocumentType类型"><a href="#DocumentType类型" class="headerlink" title="DocumentType类型"></a>DocumentType类型</h3><ul>
<li>nodeType: 10</li>
<li>nodeName: doctype的名称</li>
<li>nodeValue: null</li>
<li>parentNode: document</li>
<li>没有子节点</li>
</ul>
<h3 id="documentFragment类型"><a href="#documentFragment类型" class="headerlink" title="documentFragment类型"></a>documentFragment类型</h3><ul>
<li>nodeType: 11</li>
<li>nodeName: “#document-fragment”</li>
<li>nodeValue: null</li>
<li>parentNode: null</li>
</ul>
<h3 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h3><ul>
<li>nodeType: 2</li>
<li>nodeName: 特性名</li>
<li>nodeValue: 特性值</li>
<li>parentNode: null</li>
<li>HTML中没有子节点</li>
<li>属性：<ul>
<li>name：特性名</li>
<li>value：特性值</li>
<li>specified</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/11/webpack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godzhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/11/webpack/" itemprop="url">webpack</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-11T22:47:48+08:00">
                2017-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="webpack安装和命令行"><a href="#webpack安装和命令行" class="headerlink" title="webpack安装和命令行"></a>webpack安装和命令行</h3><p>1.项目中安装webpack</p>
<pre><code>npm init
npm install webpack --save-dev
</code></pre><p>2.将main.js打包成main.bundle.js，若main.js引用了其他文件，则一起打包</p>
<pre><code>webpack hello.js hello.bundle.js
</code></pre><p>3.若有css文件需要用到css-loader和style-loader</p>
<pre><code>npm install css-loader style-loader --save-dev
</code></pre><p>代码中要指定loader</p>
<pre><code>require(&apos;./world.js&apos;);
require(&apos;css-loader!./style.css&apos;); 
//引用style.css之前必须经过css-loader处理

function fn(){
    console.log(1);
}
</code></pre><p>要让css在页面生效，需指定style-loader</p>
<pre><code>require(&apos;style-loader!css-loader!./style.css&apos;);
</code></pre><p>css-loader使webpack可以处理.css文件，style-loader是把css-loader处理过的文件通过新建<style></style>标签插入到<head></head>里面</p>
<p>也可以不用上面的写法，可以用webpack参数</p>
<pre><code>webpack hello.js hello.bundle.js --module-bind &quot;css=style-loader!css-loader&quot;
//windows下的命令行要用双引号
</code></pre><p>每次都输入命令行太麻烦，可以用–watch命令，监听文件的变化，自动打包</p>
<pre><code>webpack hello.js hello.bundle.js --module-bind &quot;css=style-loader!css-loader&quot; --watch
</code></pre><p>其他命令</p>
<pre><code>--progress: 可以看到打包过程
--display-modules: 列出打包的模块
--display-reasons: 列出打包模块的原因
</code></pre><h3 id="建立项目的webpack配置文件"><a href="#建立项目的webpack配置文件" class="headerlink" title="建立项目的webpack配置文件"></a>建立项目的webpack配置文件</h3><p>1.若配置文件不是默认的webpack.config.js，需要用–config命令</p>
<pre><code>webpack --config webpack.dev.config.js
</code></pre><h3 id="自动化生成项目中的html"><a href="#自动化生成项目中的html" class="headerlink" title="自动化生成项目中的html"></a>自动化生成项目中的html</h3><p>1.安装插件</p>
<pre><code>npm install html-webpack-plugin --save-dev
</code></pre><p>2.使用</p>
<pre><code>var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //引入插件

module.exports = {
    entry: {                                                    
        main: &apos;./src/script/main.js&apos;,
        a: &apos;./src/script/a.js&apos;
    },
    output: {                        
        filename: &apos;./dist/js/[name]-[chunkhash].js&apos; 
    },
    plugins: [
        new htmlWebpackPlugin()                 //调用插件
    ]
}
</code></pre><p>运行npm run webpack,自动生成引用出口文件的index.html，由于没有在output中指定path，所以会在根目录下生成index.html</p>
<p>webpack2.0以上的版本需要引入path</p>
<pre><code>var path = require(&apos;path&apos;);
output: {                        
    path: path.resolve(__dirname, &apos;./dist&apos;),  //这样调用      
    filename: &apos;js/[name]-[chunkhash].js&apos;,
    publicPath: &apos;http://cdn.com/&apos;   //上线路径地址    
},
plugins: [
        new htmlWebpackPlugin()               
        //这样会在dist目录下自动生成index.html
    ]
</code></pre><p>下面是以根目录下index.html为模板创建dist下的index.html</p>
<pre><code>module.exports = {
    context: &apos;&apos;,
    //上下文路径，默认为根目录，更改会改变下面template寻找index.html的路径
    output: {                        
        path: path.resolve(__dirname, &apos;./dist&apos;),        
        filename: &apos;js/[name]-[chunkhash].js&apos;    
    },
    plugins: [      //生成的index.html是以output的path为路径
        new htmlWebpackPlugin({
            template: &apos;index.html&apos;, //这个是参考模板，以context为路径
            //其他参数
            filename: &apos;index-[hash].html&apos;,  //指定生成文件名
            inject: &apos;head&apos;                  //指定脚本放在head还是body里
            minify: {                       //对生成的html文件压缩
                removeComments: true,       //删除注释
                collapseWhitespace: true    //删除空格
            }
        })
    ] 
}
</code></pre><p>更复杂的需求，在参数中传参，模板中引用</p>
<pre><code>plugins: [     
    new htmlWebpackPlugin({
        template: &apos;index.html&apos;, 
        title: &apos;webpack is good&apos;,
        date: new Date()
    })
] 

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;%= htmlWebpackPlugin.options.date %&gt;
&lt;/body&gt;
</code></pre><p>用循环去查看htmlWebpackPlugin中哪些信息可以获取</p>
<pre><code>&lt;body&gt;
    &lt;%= htmlWebpackPlugin.options.date %&gt;

    &lt;% for(var key in htmlWebpackPlugin){ %&gt;
        &lt;div&gt;&lt;%= key %&gt;&lt;/div&gt;
    &lt;% } %&gt;
    &lt;br&gt;
    &lt;br&gt;
    &lt;% for(var key in htmlWebpackPlugin.files){ %&gt;
        &lt;div&gt;&lt;%= key %&gt; : &lt;%= JSON.stringify( htmlWebpackPlugin.files[key] ) %&gt;&lt;/div&gt;
    &lt;% } %&gt;
    &lt;br&gt;
    &lt;br&gt;
    &lt;% for(var key in htmlWebpackPlugin.options){ %&gt;
        &lt;div&gt;&lt;%= key %&gt; : &lt;%= JSON.stringify( htmlWebpackPlugin.options[key] ) %&gt;&lt;/div&gt;
    &lt;% } %&gt;
&lt;/body&gt;
</code></pre><p>结果：</p>
<pre><code>files
options

publicPath : &quot;&quot;
chunks : {&quot;main&quot;:{&quot;size&quot;:52,&quot;entry&quot;:&quot;js/main.js&quot;,&quot;hash&quot;:&quot;82a0dd8f7c8603149eea&quot;,&quot;css&quot;:[]},&quot;a&quot;:{&quot;size&quot;:74,&quot;entry&quot;:&quot;js/a.js&quot;,&quot;hash&quot;:&quot;36d04753e02412227f52&quot;,&quot;css&quot;:[]}}
js : [&quot;js/main.js&quot;,&quot;js/a.js&quot;]
css : []
manifest :


template : &quot;D:\\webpack-demo\\node_modules\\html-webpack-plugin\\lib\\loader.js!D:\\webpack-demo\\index.html&quot;
filename : &quot;index.html&quot;
hash : false
inject : true
compile : true
favicon : false
minify : false
cache : true
showErrors : true
chunks : &quot;all&quot;
excludeChunks : []
title : &quot;zhangqi&quot;
xhtml : false
date : &quot;2017-08-12T05:20:26.944Z&quot;
</code></pre><p>可以用来在模板里直接获取并引用</p>
<pre><code>&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;
    &lt;script src=&quot;&lt;%= htmlWebpackPlugin.files.chunks.main.entry %&gt;&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script src=&quot;&lt;%= htmlWebpackPlugin.files.chunks.a.entry %&gt;&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre><p><em>再深入一步，多页面应用</em></p>
<pre><code>var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);
var path = require(&apos;path&apos;);

module.exports = {
    entry: {                                     //适合多页面应用
        main: &apos;./src/script/main.js&apos;,
        a: &apos;./src/script/a.js&apos;,
        b: &apos;./src/script/b.js&apos;,
        c: &apos;./src/script/c.js&apos;
    },
    output: {                        //出口
        path: path.resolve(__dirname, &apos;./dist&apos;),        //路径
        filename: &apos;js/[name].js&apos;,   //文件名
        //publicPath: &apos;http://cdn.com/&apos;   //上线路径地址
    },
    plugins: [
        new htmlWebpackPlugin({
            template: &apos;index.html&apos;,
            filename: &apos;a.html&apos;,     //生成文件名
            inject: &apos;body&apos;,
            title: &apos;a&apos;,
            date: new Date(),
            //chunks: [&apos;main&apos;, &apos;a&apos;]   //允许只添加某些模块
            excludeChunks: [&apos;b&apos;,&apos;c&apos;]  //除了数组中的模块，其他的全部引用,和上面的相反
        }),
        new htmlWebpackPlugin({
            template: &apos;index.html&apos;,
            filename: &apos;b.html&apos;,     //生成文件名
            inject: &apos;body&apos;,
            title: &apos;b&apos;,
            date: new Date(),
            //chunks: [&apos;main&apos;, &apos;b&apos;]
            excludeChunks: [&apos;a&apos;,&apos;c&apos;]
        }),
        new htmlWebpackPlugin({
            template: &apos;index.html&apos;,
            filename: &apos;c.html&apos;,     //生成文件名
            inject: &apos;body&apos;,
            title: &apos;c&apos;,
            date: new Date(),
            //chunks: [&apos;main&apos;, &apos;c&apos;]
            excludeChunks: [&apos;b&apos;,&apos;a&apos;]
        })
    ]
}
</code></pre><p><em>再极致一些，性能优化</em><br>把main.js的代码直接写在<head></head>中<br>通过循环和判断，引入每个页面需要的js</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            &lt;%= compilation.assets[ htmlWebpackPlugin.files.chunks.main.entry.substr(htmlWebpackPlugin.files.publicPath.length) ].source() %&gt;
            //过滤掉publicPath
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;

    &lt;% for(var k in htmlWebpackPlugin.files.chunks){ %&gt;
        &lt;% if(k !== &apos;main&apos;){ %&gt;
            &lt;script src=&quot;&lt;%= htmlWebpackPlugin.files.chunks[k].entry %&gt;&quot;&gt;&lt;/script&gt;
        &lt;% } %&gt;
    &lt;% } %&gt;
    &lt;/body&gt;
&lt;/html&gt;

new htmlWebpackPlugin({
    template: &apos;index.html&apos;,
    filename: &apos;b.html&apos;,     
    inject: false,   //inject为false，在模板中手动插入
    title: &apos;b&apos;,
    date: new Date(),
    chunks: [&apos;main&apos;, &apos;b&apos;]
    //excludeChunks: [&apos;a&apos;,&apos;c&apos;]
}),
</code></pre><h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><p>安装babel</p>
<pre><code>npm install babel-loader babel-core --save-dev
npm install babel-preset-env --save-dev

module: {
    loaders: [
        {
            test: /\.js$/,                  //指定匹配文件规则
            loader: &apos;babel-loader&apos;,             //指定处理模块
            exclude: path.resolve(__dirname, &apos;./node_modules/&apos;),  
            //不处理这个路径里的文件
            include: __dirname + &apos;./src/&apos;,           //只处理的路径
            options: {
                presets: [&apos;env&apos;]
            }
        }
    ]
},
</code></pre><p>安装自动刷新热更新服务，安装webpack-dev-server执行命令：</p>
<pre><code>npm install webpack-dev-server --save-dev
</code></pre><p>在package.json文件中为scripts添加,方便使用开启服务命令:</p>
<pre><code>&quot;scripts&quot;: {  
    &quot;build&quot;: &quot;webpack&quot;,  
    &quot;dev&quot;: &quot;webpack-dev-server --devtool eval --progress --colors --content-base build&quot;  
}  
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/03/DOM方法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godzhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/03/DOM方法总结/" itemprop="url">DOM方法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-03T20:38:27+08:00">
                2017-07-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h3 id="1-getElementById"><a href="#1-getElementById" class="headerlink" title="1. getElementById()"></a>1. getElementById()</h3><p>返回对应ID的元素或者null。</p>
<h3 id="2-getElementsByTagName"><a href="#2-getElementsByTagName" class="headerlink" title="2. getElementsByTagName()"></a>2. getElementsByTagName()</h3><p>返回空([])或者一个HTMLCollection对象集合(类似NodeList)。</p>
<h3 id="3-getElementsByName"><a href="#3-getElementsByName" class="headerlink" title="3. getElementsByName()"></a>3. getElementsByName()</h3><p>返回带有给定name特性的所有元素的HTMLCollection对象集合</p>
<h3 id="4-querySelector"><a href="#4-querySelector" class="headerlink" title="4. querySelector()"></a>4. querySelector()</h3><p>接受一个css选择符，返回与该模式匹配的第一个元素或null</p>
<pre><code>var body = document.querySelector(&quot;body&quot;);
var div = document.querySelector(&quot;#div&quot;);
var sel = document.querySelector(&quot;.selected&quot;);
var img = document.querySelector(&quot;img.button&quot;);
</code></pre><h3 id="5-querySelectorAll"><a href="#5-querySelectorAll" class="headerlink" title="5. querySelectorAll()"></a>5. querySelectorAll()</h3><p>同上，返回nodeList实例或空</p>
<h3 id="6-matchesSelector"><a href="#6-matchesSelector" class="headerlink" title="6. matchesSelector()"></a>6. matchesSelector()</h3><p>接受一个css选择符，如果调用元素与该选择符匹配，返回true || false<br>不同浏览器实现方式：<br>msMatchesSelector()<br>mozMatchesSelector()<br>webkitMatchesSelector()</p>
<pre><code>var div = $(&quot;#box&quot;)[0];
console.log(div.webkitMatchesSelector(&quot;#box&quot;));  //true
</code></pre><h3 id="7-getElementsByClassNmae"><a href="#7-getElementsByClassNmae" class="headerlink" title="7. getElementsByClassNmae()"></a>7. getElementsByClassNmae()</h3><p>接收一个或多个类名的字符串，返回带有指定类的所有元素的NodeList或空<br>兼容性：IE9+</p>
<h3 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h3><h3 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h3><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h3 id="1-nodeType-每个节点都有一个nodeType属性，表明节点的类型"><a href="#1-nodeType-每个节点都有一个nodeType属性，表明节点的类型" class="headerlink" title="1. nodeType: 每个节点都有一个nodeType属性，表明节点的类型"></a>1. nodeType: 每个节点都有一个nodeType属性，表明节点的类型</h3><ul>
<li>元素节点：1</li>
<li>属性节点：2</li>
<li>文本节点：3</li>
<li>CDATASection: 4</li>
<li>注释节点：8</li>
<li>document：9</li>
<li>DocumentType: 10</li>
<li>documentFragment: 11</li>
</ul>
<h3 id="2-nodeName和nodeValue-节点的具体信息"><a href="#2-nodeName和nodeValue-节点的具体信息" class="headerlink" title="2. nodeName和nodeValue: 节点的具体信息"></a>2. nodeName和nodeValue: 节点的具体信息</h3><h6 id="nodeName"><a href="#nodeName" class="headerlink" title="nodeName:"></a>nodeName:</h6><pre><code>- 1: 元素标签名  nodeName === tagName
- 2: 特性名称
- 3: #text
- 4:
- 5:
- 6:
- 7:
- 8: #comment
- 9: #document
- 10: doctype的名称
- 11: #document-fragment
</code></pre><h6 id="nodeValue"><a href="#nodeValue" class="headerlink" title="nodeValue:"></a>nodeValue:</h6><pre><code>- 1：null
- 2: 特性值
- 3: 节点包含的文本
- 4:
- 5:
- 6:
- 7:
- 8: 注释的内容
- 9: null
- 10: null
- 11: null
</code></pre><h3 id="3-childNodes"><a href="#3-childNodes" class="headerlink" title="3. childNodes"></a>3. childNodes</h3><p>每一个节点都有一个childNodes属性，保存着一个NodeList对象(arraylike)，用于保存一组有序的节点。它实际上是基于DOM结构动态执行查询的结果，因此DOM肚饿偶的变化能够自动反应在NodeList对象中说。</p>
<h3 id="4-parentNode"><a href="#4-parentNode" class="headerlink" title="4. parentNode"></a>4. parentNode</h3><p>该属性指向文档树中的父节点</p>
<h3 id="5-previousSibling"><a href="#5-previousSibling" class="headerlink" title="5. previousSibling"></a>5. previousSibling</h3><p>节点的前一个同胞节点，列表中第一个节点的previousSibling属性值为null</p>
<h3 id="6-nextSibling"><a href="#6-nextSibling" class="headerlink" title="6. nextSibling"></a>6. nextSibling</h3><p>节点的后一个同胞节点，列表中最后一个节点的nextSibling属性值为null，如果列表中只有一个节点，该节点的previousSibling和nextSibling都为null</p>
<h3 id="7-firstChild"><a href="#7-firstChild" class="headerlink" title="7. firstChild"></a>7. firstChild</h3><p>父节点的第一个子节点</p>
<h3 id="8-lastChild"><a href="#8-lastChild" class="headerlink" title="8. lastChild"></a>8. lastChild</h3><p>父节点的最后一个子节点</p>
<h3 id="9-ownerDocument"><a href="#9-ownerDocument" class="headerlink" title="9. ownerDocument"></a>9. ownerDocument</h3><p>该属性指向表示整个文档的文档节点。任何节点只能存在于一个文档中</p>
<h3 id="10-document-documentElement"><a href="#10-document-documentElement" class="headerlink" title="10. document.documentElement"></a>10. document.documentElement</h3><p>该属性始终指向HTML页面中的<html>元素，相比document.childNodes属性访问更快捷，更直接。所有浏览器都支持该属性</html></p>
<h3 id="11-document-body"><a href="#11-document-body" class="headerlink" title="11. document.body"></a>11. document.body</h3><p>该属性指向<body>元素。所有浏览器都支持该属性</body></p>
<h3 id="12-document-doctype"><a href="#12-document-doctype" class="headerlink" title="12. document.doctype"></a>12. document.doctype</h3><p>该属性指向&lt;!DOCTYPE&gt;元素，浏览器支持差别大，见红宝书P254</p>
<pre><code>var doc = document.doctype;
console.log(doc); //&lt;!DOCTYPE html&gt;
</code></pre><h3 id="13-document-title"><a href="#13-document-title" class="headerlink" title="13. document.title"></a>13. document.title</h3><p>该属性指向<title>元素中的文本，可读写</title></p>
<h3 id="14-URL-domain-referrer"><a href="#14-URL-domain-referrer" class="headerlink" title="14. URL,domain,referrer"></a>14. URL,domain,referrer</h3><p>document.URL：页面完整的URL<br>document.domain：页面的域名（可设置）<br>document.referrer：保存着链接到当前页面的那个页面的URL</p>
<pre><code>document.URL      //&quot;https://www.baidu.com/&quot;
document.domain   //&quot;www.baidu.com&quot;
document.referrer //&quot;&quot;
</code></pre><h3 id="15-document对象特殊集合"><a href="#15-document对象特殊集合" class="headerlink" title="15. document对象特殊集合"></a>15. document对象特殊集合</h3><p>document.anchors: 所有带有name特性的<a>元素<br>document.forms: 所有的<form>元素<br>document.images: 所有的<img>元素<br>document.links: 所有带href特性的<a>元素</a></form></a></p>
<h3 id="16-textNode-data-textNode-nodeValue"><a href="#16-textNode-data-textNode-nodeValue" class="headerlink" title="16. textNode.data === textNode.nodeValue"></a>16. textNode.data === textNode.nodeValue</h3><h3 id="17-Attr节点属性"><a href="#17-Attr节点属性" class="headerlink" title="17. Attr节点属性"></a>17. Attr节点属性</h3><ul>
<li>attr.name === attr.nodeName</li>
<li>attr.value === attr.nodeValue</li>
<li>attr.specified</li>
</ul>
<h3 id="18-DOM扩展的新属性"><a href="#18-DOM扩展的新属性" class="headerlink" title="18. DOM扩展的新属性"></a>18. DOM扩展的新属性</h3><p>对于元素间的空格，不会返回文本节点<br>兼容性：IE9+</p>
<ul>
<li>childElementCount: 返回子元素的个数(不包括文本节点和注释)</li>
<li>firstElementChild: 第一个子元素</li>
<li>lastElementChild: 最后一个子元素</li>
<li>previousElementSibling: 前一个同辈元素</li>
<li>nextElementSibling: 后一个同辈元素</li>
</ul>
<h3 id="19-document-activeElement"><a href="#19-document-activeElement" class="headerlink" title="19. document.activeElement"></a>19. document.activeElement</h3><p>兼容性：IE4+<br>这个属性始终会引用DOM中当前获得了焦点的元素</p>
<pre><code>var btn = $(&quot;#btn&quot;)[0];
btn.focus();
console.log(document.activeElement); //&lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt;
</code></pre><h3 id="20-readyState"><a href="#20-readyState" class="headerlink" title="20. readyState"></a>20. readyState</h3><p>兼容性：IE4+<br>飚屎文档已经加载完成的指示器，有两个可能的值：</p>
<ul>
<li>loading: 正在加载文档</li>
<li><p>complete: 已经加载文档</p>
<p>  console.log(document.readyState);      //loading<br>  window.onload = function(){</p>
<pre><code>console.log(document.readyState);  //complete
</code></pre><p>  }</p>
</li>
</ul>
<h3 id="21-document-compatMode"><a href="#21-document-compatMode" class="headerlink" title="21. document.compatMode"></a>21. document.compatMode</h3><p>告诉开发人员浏览器采用了那种渲染模式<br>标准模式: CSS1Compat<br>混杂模式: BackCompat</p>
<h3 id="22-document-head"><a href="#22-document-head" class="headerlink" title="22. document.head"></a>22. document.head</h3><p>该属性指向<head>元素</head></p>
<pre><code>var head = document.head || document.getElementsByTagName(&quot;head&quot;)[0];
</code></pre><h3 id="23-字符集属性"><a href="#23-字符集属性" class="headerlink" title="23. 字符集属性"></a>23. 字符集属性</h3><p>document.charset: 文档中实际使用的字符集<br>document.defaultCharset: 根据默认浏览器及操作系统的设置，当前文档默认的字符集应该是什么</p>
<h3 id="24-element-dataset"><a href="#24-element-dataset" class="headerlink" title="24. element.dataset"></a>24. element.dataset</h3><p>访问自定义属性</p>
<pre><code>&lt;div id=&quot;div&quot; data-id=&quot;123&quot;&gt;&lt;/div&gt;
var div = $(&quot;#div&quot;)[0];
console.log(div.dataset.id);  //123
</code></pre><h3 id="25-innerHTML"><a href="#25-innerHTML" class="headerlink" title="25. innerHTML"></a>25. innerHTML</h3><p>读模式下，返回调用元素的所有子节点(包括元素，注释，文本节点)对应的HTML标记<br>写模式下，根据指定的值创建新的DOM树，并替换调用元素原先的所有子节点</p>
<h3 id="26-outerHTML"><a href="#26-outerHTML" class="headerlink" title="26. outerHTML"></a>26. outerHTML</h3><p>读模式下，返回调用元素和其所有子节点(包括元素，注释，文本节点)对应的HTML标签<br>写模式下，根据指定的值创建新的DOM树，并完全替换调用元素</p>
<h3 id="27-element-children-element-childNodes"><a href="#27-element-children-element-childNodes" class="headerlink" title="27. element.children === element.childNodes"></a>27. element.children === element.childNodes</h3><p>IE8之前包含注释节点，IE9之后只返回元素节点</p>
<h3 id="28"><a href="#28" class="headerlink" title="28."></a>28.</h3><h3 id="29"><a href="#29" class="headerlink" title="29."></a>29.</h3><h3 id="30"><a href="#30" class="headerlink" title="30."></a>30.</h3><h3 id="31"><a href="#31" class="headerlink" title="31."></a>31.</h3><h3 id="32"><a href="#32" class="headerlink" title="32."></a>32.</h3><h3 id="33"><a href="#33" class="headerlink" title="33."></a>33.</h3><h3 id="34"><a href="#34" class="headerlink" title="34."></a>34.</h3><h3 id="35"><a href="#35" class="headerlink" title="35."></a>35.</h3><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h3 id="1-hasChildNodes"><a href="#1-hasChildNodes" class="headerlink" title="1. hasChildNodes()"></a>1. hasChildNodes()</h3><p>作用：判断节点是否含有子节点<br>语法：node.hasChildNodes()<br>返回值：true || false<br>描述：节点包含一个或多个子节点的情况下返回true,否则返回false</p>
<h3 id="2-appendChild"><a href="#2-appendChild" class="headerlink" title="2. appendChild()"></a>2. appendChild()</h3><p>作用：向childNodes列表的末尾添加一个节点,childNodes<br>语法：fatherNode.appendChild(newNode)<br>返回值：新增的节点(newNode)</p>
<h3 id="3-insertBefore"><a href="#3-insertBefore" class="headerlink" title="3. insertBefore()"></a>3. insertBefore()</h3><p>作用：把节点插入到childNodes中特定的位置<br>语法：fatherNode.insertBefore(newNode, referNode)<br>返回值：被插入的节点<br>描述：如果referNode为null，则insertBefore === appendChild</p>
<h3 id="4-replaceChild"><a href="#4-replaceChild" class="headerlink" title="4. replaceChild()"></a>4. replaceChild()</h3><p>作用：替换节点<br>语法：fatherNode.replaceChild(newNode, referNode)<br>返回值：被替换的节点<br>描述：被替换的节点仍然还在文档中，但已经没有了自己的位置</p>
<h3 id="5-removeChild"><a href="#5-removeChild" class="headerlink" title="5. removeChild()"></a>5. removeChild()</h3><p>作用：移除节点<br>语法：fatherNode.removeChild(referNode)<br>返回值：被移除的节点<br>描述：被移除的节点仍然还在文档中，但已经没有了自己的位置</p>
<h3 id="6-cloneNode"><a href="#6-cloneNode" class="headerlink" title="6. cloneNode()"></a>6. cloneNode()</h3><p>作用：创建目标节点的一个完全相同的副本<br>语法：referNode.clone(boolean)<br>返回值：复制得到的副本<br>描述：参数为true，执行深复制，复制节点及其整个子节点数。参数为false，执行浅复制，只复制节点本身</p>
<h3 id="7-normalize"><a href="#7-normalize" class="headerlink" title="7. normalize()"></a>7. normalize()</h3><p>作用：处理文档树中的文本节点<br>语法：node.normalize()<br>描述：如果在一个包含两个或多个文本节点的父元素上调用normalize()方法，则会将所有文本节点合并成一个节点，nodeValue等于每个文本节点的nodeValue值拼接起来的值</p>
<pre><code>&lt;div&gt;&lt;/div&gt;
var div = $(&quot;div&quot;)[0];
var text_1 = document.createTextNode(&quot;zhangqi&quot;);
div.appendChild(text_1);
var text_2 = document.createTextNode(&quot;zhaojinge&quot;);
div.appendChild(text_2);
console.log(div.childNodes.length);
div.normalize();
console.log(div.childNodes.length);
console.log(div.childNodes[0]);  //&quot;zhangqizhaojinge&quot;
</code></pre><h3 id="8-namedItem"><a href="#8-namedItem" class="headerlink" title="8. namedItem()"></a>8. namedItem()</h3><p>作用：通过元素的name特性取得集合中的项<br>语法：list.namedItem(name)<br>描述：此方法为HTMLCollection对象的方法</p>
<h3 id="9-document-implementation-hasFeature"><a href="#9-document-implementation-hasFeature" class="headerlink" title="9. document.implementation.hasFeature()"></a>9. document.implementation.hasFeature()</h3><p>作用：检测浏览器是否支持给定的名称和版本的功能<br>语法：document.implementation.hasFeature(“XML”, “1.0”)<br>返回值：true || false<br>描述：建议同时使用能力检测</p>
<h3 id="10-document文档写入"><a href="#10-document文档写入" class="headerlink" title="10. document文档写入"></a>10. document文档写入</h3><ul>
<li>document.write(), document.writeln()</li>
</ul>
<p>作用：将指定内容写入到网页中<br>描述：write()会原样写入，writeln()会在末尾添加一个换行符(\n),这里的换行在源码中能看出区别，实际页面效果中，会产生一个空格。</p>
<ul>
<li>document.open()</li>
</ul>
<p>作用：用于打开和关闭网页的输出流<br>语法：document.open(mimetype, replace)</p>
<h6 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h6><ul>
<li>mimetype: 可选。规定正在写的文档的类型。默认值是”text/html”。</li>
<li>replace: 可选。当此参数设置后，可引起新文档从父文档继承历史条目。</li>
</ul>
<h6 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h6><ul>
<li>open()方法将擦除当前HTML文档的内容，开始一个新的文档，新文档用write()方法或writeln()方法编写。</li>
<li>调用open()方法打开一个新文档并且用write()方法设置文档内容后，必须记住用close()方法关闭文档，并迫使其内容显示出来。</li>
<li><p>属于被覆盖的文档的一部分的脚本或事件句柄不能调用该方法，因为脚本或事件句柄自身也会被覆盖。</p>
</li>
<li><p>document.close()</p>
</li>
</ul>
<p>作用：关闭一个由open()方法打开的输出流，并显示选定的数据。<br>语法：document.close()</p>
<h6 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h6><ul>
<li>该方法将关闭open()方法打开的文档流，并强制地显示出所有缓存的输出内容。如果您使用write()方法动态地输出一个文档，必须记住当你这么做的时候要调用close()方法，以确保所有文档内容都能显示。document.write()不会隐式调用document.close()方法的，否则例2中将不会有This is a new window.内容了</li>
<li>一旦调用了close()，就不应该再次调用write()，因为这会隐式地调用open()来擦除当前文档并开始一个新的文档。 </li>
<li>在载入页面后，浏览器输出流自动关闭。在此之后，比如延迟脚本[setTimeout()]或是onload执行的方法，任何一个对当前页面进行操作的document.write()方法将打开—个新的输出流，它将清除当前页面内容(包括源文档的任何变量或值)。</li>
</ul>
<h3 id="11-getAttribute"><a href="#11-getAttribute" class="headerlink" title="11. getAttribute()"></a>11. getAttribute()</h3><p>作用：获取元素特性值<br>返回值：特性值或null<br>描述：开发人员经常不使用getAttribute(),而只使用对象的属性，只有在取得自定义特性值的情况下，才会使用getAttribute()方法</p>
<h3 id="12-setAttribute"><a href="#12-setAttribute" class="headerlink" title="12. setAttribute()"></a>12. setAttribute()</h3><p>作用：设置特性<br>语法：node.setAttribute(name, value)<br>描述：如果特性存在，替换。不存在，创建。为DOM元素添加一个自定义的属性，该属性不会自动成为元素的特性</p>
<pre><code>div.mycolor = &apos;red&apos;;
alert(div.getAttribute(&quot;mycolor&quot;));  //null(IE除外)
</code></pre><h3 id="13-removeAttribute"><a href="#13-removeAttribute" class="headerlink" title="13. removeAttribute()"></a>13. removeAttribute()</h3><p>作用：彻底删除元素的特性<br>语法：node.removeAttribute(name)<br>兼容性: IE6-<br>描述：该方法不仅会清除特性的值，也会从元素中完全删除特性。</p>
<h3 id="14-attributes属性方法（读写）"><a href="#14-attributes属性方法（读写）" class="headerlink" title="14. attributes属性方法（读写）"></a>14. attributes属性方法（读写）</h3><pre><code>1. attributes.getNamedItem(name): 返回nodeName属性等于name的节点
2. attributes.removeNamedItem(name)：从列表中移除nodeName属性等于name的节点,返回被删除特性的Attr节点
3. attributes.setNamedItem(node)：向列表中添加节点，一节点的nodeName属性为索引
4. attributes.item(pos)：返回位于数字pos位置处的节点

&lt;a href=&quot;&quot; class=&quot;a2&quot; name=&quot;zhangqi&quot; id=&quot;zhangqi&quot;&gt;&lt;/a&gt;
var elem = $(&quot;.a2&quot;)[0];
var id = elem.attributes;    //NamedNodeMap {0: href, 1: class, 2: name, 3: id, length: 4}
var id = elem.attributes.getNamedItem(&quot;id&quot;);  //id=&quot;zhangqi&quot;
var id = elem.attributes[&quot;id&quot;];  //id=&quot;zhangqi&quot;
var id = elem.attributes.getNamedItem(&quot;id&quot;).nodeName;  //id
var id = elem.attributes.getNamedItem(&quot;id&quot;).nodeValue; //zhangqi
console.log(elem.attributes[&apos;id&apos;].specified); //true
console.log(elem.attributes[&apos;type&apos;].specified); //false,实际会报错

//遍历枚举属性
var elem = $(&quot;.a2&quot;)[0];
var arr = [];
for(var i=0,len=elem.attributes.length;i&lt;len;i++){
    var name = elem.attributes[i].nodeName;
    var value = elem.attributes[i].nodeValue;
    if(!elem.attributes[i].specified) continue;
    arr.push(name + &quot;=&quot; + value + &apos;\\&apos;);
} 
console.log(arr);  //[&quot;href=\&quot;, &quot;class=a2\&quot;, &quot;name=zhangqi\&quot;, &quot;id=zhangqi\&quot;]
</code></pre><h3 id="15-document-createElement"><a href="#15-document-createElement" class="headerlink" title="15. document.createElement()"></a>15. document.createElement()</h3><p>作用：创建新元素<br>语法：document.createElement(“div”)<br>描述：在使用createElement()方法创建新元素的同时，也为新元素设置了ownerDocument属性</p>
<pre><code>document.createElement(&quot;div&quot;);
document.createElement(&quot;&lt;div id=\&quot;zhangqi\&quot; class=\&quot;box\&quot;&gt;&lt;/div&gt;&quot;);
//指定完整标签能避开IE7中创建元素的某些问题
</code></pre><h3 id="16-操作文本结点方法"><a href="#16-操作文本结点方法" class="headerlink" title="16. 操作文本结点方法"></a>16. 操作文本结点方法</h3><ul>
<li>appendData(text)：将text添加到节点的末尾</li>
<li>deleteData(offset, count)：从offset指定的位置开始删除count个字符</li>
<li>insertData(offset, text)：在offset指定的位置插入text</li>
<li>replaceData(offset, count, text)：用text替换从offset指定的位置开始到offset+count为止处的文本</li>
<li>splitText(offset)：从offset指定的位置将当前文本节点分成两个文本节点</li>
<li>substringData(offset, count)：提取从offset指定的位置开始到offset+count为止处的字符</li>
</ul>
<p>#<br>    <div>111</div><br>    var div = $(“div”)[0];<br>    var text = div.childNodes[0];<br>    text.appendData(“222”); //111222<br>    text.deleteData(2, 2);   //1122<br>    text.insertData(1, “zhangqi”); //1zhangqi122<br>    text.replaceData(1,7,”zhaojinge”); //1zhaojinge122<br>    var back = text.splitText(3);<br>    console.log(back);  //aojinge122<br>    console.log(text);  //1zh<br>    var str = back.substringData(1, 3);<br>    console.log(back);  //aojinge122<br>    console.log(str);  //oji</p>
<h3 id="17-document-createTextNode"><a href="#17-document-createTextNode" class="headerlink" title="17. document.createTextNode()"></a>17. document.createTextNode()</h3><p>作用：创建新的文本节点<br>语法：document.createTextNode(text)</p>
<h3 id="18-splitText"><a href="#18-splitText" class="headerlink" title="18. splitText()"></a>18. splitText()</h3><p>作用：将文本节点分成两个文本节点<br>语法：textNode.splitText(num)<br>描述：原来的文本节点包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本</p>
<pre><code>&lt;div&gt;zhangqizhaojinge&lt;/div&gt;
var div = $(&quot;div&quot;)[0];
var text = div.childNodes[0];
var nextText = text.splitText(7);
console.log(text);     //&quot;zhangqi&quot;
console.log(nextText); //&quot;zhaojinge&quot;
</code></pre><h3 id="19-document-createComment"><a href="#19-document-createComment" class="headerlink" title="19. document.createComment()"></a>19. document.createComment()</h3><p>作用：创建注释节点<br>语法：document.createComment(text)<br>描述：如果要访问注释节点，一定要保证他们是<html>元素的后代</html></p>
<h3 id="20-document-createCDATASection"><a href="#20-document-createCDATASection" class="headerlink" title="20. document.createCDATASection()"></a>20. document.createCDATASection()</h3><p>作用：创建CDATA区域</p>
<h3 id="21-document-createDocumentFragment"><a href="#21-document-createDocumentFragment" class="headerlink" title="21. document.createDocumentFragment()"></a>21. document.createDocumentFragment()</h3><p>作用：创建文档碎片<br>语法：document.createDocumentFragment()<br>描述：文档片段本身永远不会成为文档树的一部分</p>
<pre><code>&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
var div = $(&quot;#box&quot;)[0];
var frag = document.createDocumentFragment();
var a = document.createElement(&quot;div&quot;);
a.id = &apos;zhangqi&apos;;
frag.appendChild(a);
var b = document.createElement(&quot;div&quot;);
b.id = &apos;zhaojinge&apos;;
frag.appendChild(b);
div.appendChild(frag);
//&lt;div id=&quot;box&quot;&gt;
//    &lt;div id=&quot;zhangqi&quot;&gt;&lt;/div&gt;
//    &lt;div id=&quot;zhaojinge&quot;&gt;&lt;/div&gt;
//&lt;/div&gt;
</code></pre><h3 id="22-document-createAttribute"><a href="#22-document-createAttribute" class="headerlink" title="22. document.createAttribute()"></a>22. document.createAttribute()</h3><p>作用：创建新的特性节点<br>语法：document.createAttribute(char)</p>
<h3 id="23-element-getAttributeNode"><a href="#23-element-getAttributeNode" class="headerlink" title="23. element.getAttributeNode()"></a>23. element.getAttributeNode()</h3><p>作用：获取属性节点<br>语法：element.getAttributeNode(name)</p>
<pre><code>var div = $(&quot;#box&quot;)[0];
var attr = div.getAttributeNode(&quot;id&quot;);
console.log(attr);  //id=&quot;box&quot;
</code></pre><h3 id="24-classList属性方法"><a href="#24-classList属性方法" class="headerlink" title="24. classList属性方法"></a>24. classList属性方法</h3><ul>
<li>add(value): 将给定字符串添加到列表，如果存在则不添加</li>
<li>contains(value): 列表中是否存在给定的值</li>
<li>remove(value): 从列表中删除给定的字符串</li>
<li>toggle(value): 添加或删除给定的字符串</li>
</ul>
<h3 id="25-document-hasFoucs"><a href="#25-document-hasFoucs" class="headerlink" title="25. document.hasFoucs()"></a>25. document.hasFoucs()</h3><p>作用: 用于确定文档是否获得了焦点</p>
<pre><code>var btn = $(&quot;#btn&quot;)[0];
btn.focus();
console.log(document.hasFocus()); // true
</code></pre><h3 id="26-insertAdjacentHTML"><a href="#26-insertAdjacentHTML" class="headerlink" title="26. insertAdjacentHTML()"></a>26. insertAdjacentHTML()</h3><p>作用：插入标记<br>语法：element.insertAdjacentHTML(offset, html)<br>参数：</p>
<h6 id="offset-插入位置，只有四种值"><a href="#offset-插入位置，只有四种值" class="headerlink" title="offset: 插入位置，只有四种值"></a>offset: 插入位置，只有四种值</h6><ul>
<li>beforebegin: 当前元素之前插入一个同辈元素</li>
<li>afterbegin: 在当前元素之下插入新的子元素活在第一个子元素之前插入新元素</li>
<li>beforeend: 在当前元素之下插入新的子元素活在最后一个子元素之后插入新元素</li>
<li>afterend: 当前元素之后插入一个同辈元素</li>
</ul>
<h3 id="27-scrollIntoView"><a href="#27-scrollIntoView" class="headerlink" title="27. scrollIntoView()"></a>27. scrollIntoView()</h3><p>作用：通过滚动浏览器窗口或容器窗口，使调用元素出现在视口中<br>语法：elem.scrollIntoView(boolean)<br>参数：默认为true</p>
<ul>
<li>true: 调用元素顶部与视口顶部尽可能平齐</li>
<li>false: 调用元素全部出现在视口中(可能的话，底部与底部平齐)</li>
</ul>
<h3 id="28-contains"><a href="#28-contains" class="headerlink" title="28. contains()"></a>28. contains()</h3><p>alert(document.documentElement.contains(document.body)); //true</p>
<h3 id="29-compareDocumentPosition"><a href="#29-compareDocumentPosition" class="headerlink" title="29. compareDocumentPosition()"></a>29. compareDocumentPosition()</h3><p>作用：确定节点关系<br>语法：elem.compareDocumentPosition(elem)<br>返回值：</p>
<ul>
<li>1: 无关</li>
<li>2: 居前</li>
<li>4: 居后</li>
<li>8: 包含</li>
<li><p>16: 被包含</p>
<p>  console.log(document.documentElement.compareDocumentPosition(document.body));  //20</p>
</li>
</ul>
<h3 id="30-1"><a href="#30-1" class="headerlink" title="30."></a>30.</h3><h3 id="31-1"><a href="#31-1" class="headerlink" title="31."></a>31.</h3><h3 id="32-1"><a href="#32-1" class="headerlink" title="32."></a>32.</h3><h3 id="33-1"><a href="#33-1" class="headerlink" title="33."></a>33.</h3><h3 id="34-1"><a href="#34-1" class="headerlink" title="34."></a>34.</h3><h3 id="35-1"><a href="#35-1" class="headerlink" title="35."></a>35.</h3><h3 id="36"><a href="#36" class="headerlink" title="36."></a>36.</h3><h3 id="37"><a href="#37" class="headerlink" title="37."></a>37.</h3><h3 id="38"><a href="#38" class="headerlink" title="38."></a>38.</h3><h3 id="39"><a href="#39" class="headerlink" title="39."></a>39.</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/28/RegExp对象内置方法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godzhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/RegExp对象内置方法总结/" itemprop="url">RegExp对象内置方法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T20:42:46+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="1-RegExp-prototype-flags"><a href="#1-RegExp-prototype-flags" class="headerlink" title="1. RegExp.prototype.flags"></a>1. RegExp.prototype.flags</h2><p>flags属性返回一个字符串，由当前正则表达式对象的标志组成。<br>flags属性中的标志以字典序排序（从左到右，即”gimuy”）</p>
<pre><code>/foo/ig.flags;   // &quot;gi&quot;
/bar/myu.flags;  // &quot;muy&quot;
</code></pre><p>兼容性：chrome, firefox<br>版本：ES6</p>
<h2 id="2-RegExp-prototype-global"><a href="#2-RegExp-prototype-global" class="headerlink" title="2. RegExp.prototype.global"></a>2. RegExp.prototype.global</h2><p>global 属性表明正则表达式是否使用了 “g” 标志。global 是一个正则表达式实例的只读属性</p>
<pre><code>var regex = new RegExp(&quot;foo&quot;, &quot;g&quot;)
console.log(regex.global) // true
</code></pre><p>兼容性：all<br>版本：ES3</p>
<h2 id="3-RegExp-prototype-ignoreCase"><a href="#3-RegExp-prototype-ignoreCase" class="headerlink" title="3. RegExp.prototype.ignoreCase"></a>3. RegExp.prototype.ignoreCase</h2><p>ignoreCase 属性表明正则表达式是否使用了 “i” 标志。ignoreCase 是正则表达式实例的只读属性</p>
<pre><code>var regex = new RegExp(&quot;foo&quot;, &quot;i&quot;)
console.log(regex.ignoreCase) // true
</code></pre><p>兼容性：all<br>版本：ES3</p>
<h2 id="4-RegExp-prototype-multiline"><a href="#4-RegExp-prototype-multiline" class="headerlink" title="4. RegExp.prototype.multiline"></a>4. RegExp.prototype.multiline</h2><p>multiline 属性表明正则表达式是否使用了 “m” 标志。multiline 是正则表达式实例的一个只读属性</p>
<p>var regex = new RegExp(“foo”, “m”)<br>console.log(regex.multiline) // true</p>
<p>兼容性：all<br>版本：ES3</p>
<h2 id="5-RegExp-prototype-source"><a href="#5-RegExp-prototype-source" class="headerlink" title="5. RegExp.prototype.source"></a>5. RegExp.prototype.source</h2><p>source 属性返回一个值为当前正则表达式对象的模式文本的字符串，该字符串不会包含正则字面量两边的斜杠以及任何的标志字符。</p>
<pre><code>var regex = /fooBar/ig;
console.log(regex.source); // &quot;fooBar&quot;，不包含 /.../ 和 &quot;ig&quot;。
</code></pre><p>兼容性：all<br>版本：ES3</p>
<h2 id="6-RegExp-prototype-sticky"><a href="#6-RegExp-prototype-sticky" class="headerlink" title="6. RegExp.prototype.sticky"></a>6. RegExp.prototype.sticky</h2><p>sticky 属性反映了搜索是否具有粘性（ 仅从正则表达式的 lastIndex 属性表示的索引处搜索 ）。sticky 是正则表达式对象的只读属性。<br>sticky 的值是 Boolean ，并在“y”标志使用时为真; 否则为假。”y” 标志指示，仅从正则表达式的 lastIndex 属性表示的索引处为目标字符串匹配（并且不会尝试从后续索引匹配）。</p>
<pre><code>var regex = /foo/y;
console.log(regex.sticky) //true
</code></pre><p>兼容性：firefox<br>版本：ES6</p>
<h2 id="7-RegExp-prototype-unicode"><a href="#7-RegExp-prototype-unicode" class="headerlink" title="7. RegExp.prototype.unicode"></a>7. RegExp.prototype.unicode</h2><p>unicode 属性表明正则表达式带有”u” 标志。 unicode 是正则表达式独立实例的只读属性。</p>
<pre><code>var regex = new RegExp(&apos;\u{61}&apos;, &apos;u&apos;);
console.log(regex.unicode); // true
</code></pre><p>兼容性：IE-<br>版本：ES6</p>
<h2 id="8-RegExp-lastIndex"><a href="#8-RegExp-lastIndex" class="headerlink" title="8. RegExp.lastIndex"></a>8. RegExp.lastIndex</h2><p>lastIndex 是正则表达式的一个可读可写的整型属性，用来指定下一次匹配的起始索引。</p>
<p>只有正则表达式使用了表示全局检索的 “g” 标志时，该属性才会起作用。此时应用下面的规则：</p>
<ul>
<li>如果 lastIndex 大于字符串的长度，则 regexp.test 和 regexp.exec 将会匹配失败，然后 lastIndex 被设置为 0。</li>
<li>如果 lastIndex 等于字符串的长度，且该正则表达式匹配空字符串，则该正则表达式匹配从 lastIndex 开始的字符串。（then the regular expression matches input starting at lastIndex.）</li>
<li>如果 lastIndex 等于字符串的长度，且该正则表达式不匹配空字符串 ，则该正则表达式不匹配字符串，lastIndex 被设置为 0.。</li>
<li><p>否则，lastIndex 被设置为紧随最近一次成功匹配的下一个位置。</p>
<p>  var reg = /(zhangqi)/g;<br>  console.log(reg.exec(‘zhangqizhenlihai’));<br>  //[“zhangqi”, “zhangqi”, index: 0, input: “zhangqizhenlihai”]<br>  console.log(reg.lastIndex); //7</p>
</li>
</ul>
<p>兼容性：all<br>版本：ES3</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="1-RegExp-prototype-exec"><a href="#1-RegExp-prototype-exec" class="headerlink" title="1. RegExp.prototype.exec()"></a>1. RegExp.prototype.exec()</h2><p>作用：在一个指定字符串中执行一个搜索匹配，返回一个结果数组或null<br>语法：regexObj.exec(str)<br>参数：str: 要匹配正则表达式的字符串<br>返回值：success ? [match_item, q1, q2,… index, input] : null<br>是否改变原对象：false<br>兼容性：all<br>版本：ES3<br>描述：当正则表达式使用 “g” 标志时，可以多次执行 exec 方法来查找同一个字符串中的成功匹配。</p>
<p>如果 exec() 找到了匹配的文本，则返回一个结果数组<br>此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。</p>
<pre><code>var myRe = /ab*/g;
var str = &apos;abbcdefabh&apos;;
var myArray;
while ((myArray = myRe.exec(str)) !== null) {
  var msg = &apos;Found &apos; + myArray[0] + &apos;. &apos;;
  msg += &apos;Next match starts at &apos; + myRe.lastIndex;
  console.log(msg);
}
//Found abb. Next match starts at 3
//Found ab. Next match starts at 9

var matches = /(hello \S+)/.exec(&apos;This is a hello world!&apos;);
console.log(matches);
//[&quot;hello world!&quot;, &quot;hello world!&quot;, index: 10, input: &quot;This is a hello world!&quot;]
</code></pre><h2 id="2-RegExp-prototype-test"><a href="#2-RegExp-prototype-test" class="headerlink" title="2. RegExp.prototype.test()"></a>2. RegExp.prototype.test()</h2><p>作用：执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false<br>语法：regexObj.test(str)<br>参数：str: 用来与正则表达式匹配的字符串<br>返回值：true || false<br>是否改变原对象：false<br>兼容性：all<br>版本：ES3<br>描述：</p>
<pre><code>let str = &apos;hello world!&apos;;
let result = /^hello/.test(str);
console.log(result); // true
</code></pre><h2 id="3-RegExp-prototype-toSource-————unstandard"><a href="#3-RegExp-prototype-toSource-————unstandard" class="headerlink" title="3. RegExp.prototype.toSource()————unstandard"></a>3. RegExp.prototype.toSource()————unstandard</h2><p>作用：一个字符串,代表当前对象的源代码<br>语法：regexObj.toSource()<br>参数：无<br>返回值：当前对象的源代码<br>是否改变原对象：false<br>兼容性：firefox<br>版本：—<br>描述：该方法通常由JavaScript内部隐含调用,而不会明确的出现在用户代码中.</p>
<pre><code>var reg = /(hello \S+)/;
console.log(reg.toSource());// /(hello \S+)/
</code></pre><h2 id="4-RegExp-prototype-toString"><a href="#4-RegExp-prototype-toString" class="headerlink" title="4. RegExp.prototype.toString()"></a>4. RegExp.prototype.toString()</h2><p>作用：返回一个表示该正则表达式的字符串<br>语法：regexObj.toString()<br>参数：无<br>返回值：表示该正则表达式的字符串<br>是否改变原对象：false<br>兼容性：all<br>版本：ES3<br>描述：RegExp 对象覆盖了 Object 对象的 toString() 方法，并没有继承 Object.prototype.toString()。对于 RegExp 对象，toString 方法返回一个该正则表达式的字符串形式。</p>
<p>var reg = /(hello \S+)/;<br>var str = reg.toString();<br>console.log(str); // /(hello \S+)/</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/28/Number对象内置方法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godzhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/Number对象内置方法总结/" itemprop="url">Number对象内置方法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T20:42:46+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="1-Number-EPSILON"><a href="#1-Number-EPSILON" class="headerlink" title="1. Number.EPSILON"></a>1. Number.EPSILON</h2><p>Number.EPSILON 属性表示 1 和大于 1 的最小值（可表示为 Number）的差值。<br>EPSILON 属性的值接近于 2.2204460492503130808472633361816E-16，或者 2-52。</p>
<pre><code>var x = 0.2,
    y = 0.3,
    z = 0.1;
console.log(Math.abs(x-y+z) &lt; Number.EPSILON); //true
</code></pre><p><strong>兼容性：</strong>IE-<br><strong>版本：</strong>ES6</p>
<h2 id="2-Number-MAX-SAFE-INTEGER"><a href="#2-Number-MAX-SAFE-INTEGER" class="headerlink" title="2. Number.MAX_SAFE_INTEGER"></a>2. Number.MAX_SAFE_INTEGER</h2><p>Number.MAX_SAFE_INTEGER 常量表示在 JavaScript 中最大的安全整数（253 - 1）<br>MAX_SAFE_INTEGER 常量值为 9007199254740991</p>
<pre><code>Number.MAX_SAFE_INTEGER // 9007199254740991, IE全部返回undefined
</code></pre><p><strong>兼容性：</strong>IE-<br><strong>版本：</strong>ES6</p>
<h2 id="3-Number-MAX-VALUE"><a href="#3-Number-MAX-VALUE" class="headerlink" title="3. Number.MAX_VALUE"></a>3. Number.MAX_VALUE</h2><p>Number.MAX_VALUE 属性表示在 JavaScript 里所能表示的最大数值<br>MAX_VALUE 属性值接近于 1.79E+308。大于 MAX_VALUE 的值代表 “Infinity”</p>
<pre><code>console.log(Number.MAX_VALUE); //1.7976931348623157e+308
</code></pre><p><strong>兼容性：</strong>all<br><strong>版本：</strong>ES1</p>
<h2 id="4-Number-MIN-SAFE-INTEGER"><a href="#4-Number-MIN-SAFE-INTEGER" class="headerlink" title="4. Number.MIN_SAFE_INTEGER"></a>4. Number.MIN_SAFE_INTEGER</h2><p>Number.MIN_SAFE_INTEGER 代表在 JavaScript中最小的安全的integer型数字 (-(253 - 1))<br>MIN_SAFE_INTEGER 的值是-9007199254740991</p>
<pre><code>Number.MIN_SAFE_INTEGER // -9007199254740991, IE全部返回undefined
</code></pre><p><strong>兼容性：</strong>IE- Safari-<br><strong>版本：</strong>ES6</p>
<h2 id="5-Number-MIN-VALUE"><a href="#5-Number-MIN-VALUE" class="headerlink" title="5. Number.MIN_VALUE"></a>5. Number.MIN_VALUE</h2><p>Number.MIN_VALUE 属性表示在 JavaScript 中最接近0的最小的正值,而不是最小的负值<br>MIN_VALUE 的值约为 5e-324。小于 MIN_VALUE (“underflow values”) 的值将会转换为 0</p>
<pre><code>console.log(Number.MIN_VALUE); //5e-324
</code></pre><p><strong>兼容性：</strong>all<br><strong>版本：</strong>ES1</p>
<h2 id="6-Number-NEGATIVE-INFINITY"><a href="#6-Number-NEGATIVE-INFINITY" class="headerlink" title="6. Number.NEGATIVE_INFINITY"></a>6. Number.NEGATIVE_INFINITY</h2><p>Number.NEGATIVE_INFINITY 属性表示负无穷大,和全局对象的 Infinity 属性的负值相同</p>
<p><strong>兼容性：</strong>all<br><strong>版本：</strong>ES1</p>
<h2 id="7-Number-NaN"><a href="#7-Number-NaN" class="headerlink" title="7. Number.NaN"></a>7. Number.NaN</h2><p>Number.NaN 表示“非数字”（Not-A-Number）。和 NaN 相同</p>
<p><strong>兼容性：</strong>all<br><strong>版本：</strong>ES1</p>
<h2 id="8-Number-POSITIVE-INFINITY"><a href="#8-Number-POSITIVE-INFINITY" class="headerlink" title="8. Number.POSITIVE_INFINITY"></a>8. Number.POSITIVE_INFINITY</h2><p>Number.POSITIVE_INFINITY 属性表示正无穷大,同全局对象 Infinity 属性的值相同</p>
<p><strong>兼容性：</strong>all<br><strong>版本：</strong>ES1</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="1-Number-isFinite"><a href="#1-Number-isFinite" class="headerlink" title="1. Number.isFinite()"></a>1. Number.isFinite()</h2><p><strong>作用：</strong>用来检测传入的参数是否是一个有穷数<br><strong>语法：</strong>Number.isFinite(value)<br><strong>参数：</strong>value: 被检测的值<br><strong>返回值：</strong>true || false<br><strong>是否改变原对象：</strong>false<br><strong>兼容性：</strong>IE-<br><strong>版本：</strong>ES6<br><strong>描述：</strong>和全局的 isFinite() 函数相比，这个方法不会强制将一个非数值的参数转换成数值，这就意味着，只有数值类型的值，且是有穷的（finite），才返回 true。</p>
<pre><code>console.log(Number.isFinite(Infinity));  //false
console.log(Number.isFinite(NaN));       //false
console.log(Number.isFinite(-Infinity)); //false
console.log(Number.isFinite(0));         //true
console.log(Number.isFinite(2e64));      //true
console.log(Number.isFinite(&apos;0&apos;));       //false
console.log(isFinite(&apos;0&apos;));              //true
</code></pre><h2 id="2-Number-isInteger"><a href="#2-Number-isInteger" class="headerlink" title="2. Number.isInteger()"></a>2. Number.isInteger()</h2><p><strong>作用：</strong>用来判断给定的参数是否为整数<br><strong>语法：</strong>Number.isInteger(value)<br><strong>参数：</strong>value<br><strong>返回值：</strong>true || false<br><strong>是否改变原对象：</strong>false<br><strong>兼容性：</strong>IE-<br><strong>版本：</strong>ES6<br><strong>描述：</strong>NaN 和正负 Infinity 不是整数</p>
<pre><code>Number.isInteger(0);         // true
Number.isInteger(1);         // true
Number.isInteger(-100000);   // true

Number.isInteger(0.1);       // false
Number.isInteger(Math.PI);   // false

Number.isInteger(Infinity);  // false
Number.isInteger(-Infinity); // false
Number.isInteger(&quot;10&quot;);      // false
Number.isInteger(true);      // false
Number.isInteger(false);     // false
Number.isInteger([1]);       // false
</code></pre><h2 id="3-Number-isNaN"><a href="#3-Number-isNaN" class="headerlink" title="3. Number.isNaN()"></a>3. Number.isNaN()</h2><p><strong>作用：</strong>确定传递的值是否为 NaN和其类型是 Number<br><strong>语法：</strong>Number.isNaN(value)<br><strong>参数：</strong>value<br><strong>返回值：</strong>true || false<br><strong>是否改变原对象：</strong>false<br><strong>兼容性：</strong>IE- Safari-<br><strong>版本：</strong>ES6<br><strong>描述：</strong>在 JavaScript 中，NaN 最特殊的地方就是，我们不能使用相等运算符（== 和 ===）来判断一个值是否是 NaN，因为 NaN == NaN 和 NaN === NaN 都会返回 false。因此，必须要有一个判断值是否是 NaN 的方法。</p>
<p>和全局函数 isNaN() 相比，该方法不会强制将参数转换成数字，只有在参数是真正的数字类型，且值为 NaN 的时候才会返回 true。</p>
<pre><code>Number.isNaN(NaN);        // true
Number.isNaN(Number.NaN); // true
Number.isNaN(0 / 0)       // true

// 下面这几个如果使用全局的 isNaN() 时，会返回 true。
Number.isNaN(&quot;NaN&quot;);      // false，字符串 &quot;NaN&quot; 不会被隐式转换成数字 NaN。
Number.isNaN(undefined);  // false
Number.isNaN({});         // false
Number.isNaN(&quot;blabla&quot;);   // false

// 下面的都返回 false
Number.isNaN(true);
Number.isNaN(null);
Number.isNaN(37);
Number.isNaN(&quot;37&quot;);
Number.isNaN(&quot;37.37&quot;);
Number.isNaN(&quot;&quot;);
Number.isNaN(&quot; &quot;);
</code></pre><h2 id="4-Number-isSafeInteger"><a href="#4-Number-isSafeInteger" class="headerlink" title="4. Number.isSafeInteger()"></a>4. Number.isSafeInteger()</h2><p><strong>作用：</strong>判断传入的参数值是否是一个“安全整数”<br><strong>语法：</strong>Number.isSafeInteger(testValue)<br><strong>参数：</strong>testValue<br><strong>返回值：</strong>true || false<br><strong>是否改变原对象：</strong>false<br><strong>兼容性：</strong>IE-<br><strong>版本：</strong>ES6<br><strong>描述：</strong>安全整数范围为 -(2^53 - 1)到 2^53 - 1 之间的整数，包含 -(2^53 - 1)和 2^53 - 1</p>
<pre><code>Number.isSafeInteger(3);                    // true
Number.isSafeInteger(Math.pow(2, 53))       // false
Number.isSafeInteger(Math.pow(2, 53) - 1)   // true
Number.isSafeInteger(NaN);                  // false
Number.isSafeInteger(Infinity);             // false
Number.isSafeInteger(&quot;3&quot;);                  // false
Number.isSafeInteger(3.1);                  // false
Number.isSafeInteger(3.0);                  // true
</code></pre><h2 id="5-Number-parseFloat"><a href="#5-Number-parseFloat" class="headerlink" title="5. Number.parseFloat()"></a>5. Number.parseFloat()</h2><p><strong>作用：</strong>把一个字符串解析成浮点数<br><strong>语法：</strong>Number.parseFloat(string)<br><strong>参数：</strong>string: 被解析的字符串<br><strong>返回值：</strong>解析后的值<br><strong>是否改变原对象：</strong>false<br><strong>兼容性：</strong>IE- Safari-<br><strong>版本：</strong>ES6<br><strong>描述：</strong>该方法和全局的 parseFloat() 函数是同一个函数</p>
<pre><code>parseFloat(&quot;3.14&quot;);   //3.14
parseFloat(&quot;314e-2&quot;);   //3.14
parseFloat(&quot;0.0314E+2&quot;);   //3.14
parseFloat(&quot;3.14more non-digit characters&quot;);   //3.14
parseFloat(&quot;FF2&quot;);  //NaN
</code></pre><h2 id="6-Number-parseInt"><a href="#6-Number-parseInt" class="headerlink" title="6. Number.parseInt()"></a>6. Number.parseInt()</h2><p><strong>作用：</strong>根据给定的进制数把一个字符串解析成整数<br><strong>语法：</strong>Number.parseInt(string, radix)<br><strong>参数：</strong>解析后的值</p>
<ul>
<li>string: 被解析的值</li>
<li>radix: 进制转换基数</li>
</ul>
<p><strong>返回值：</strong><br><strong>是否改变原对象：</strong><br><strong>兼容性：</strong>IE- Safari-<br><strong>版本：</strong>ES6<br><strong>描述：</strong>该方法和全局的 parseInt() 函数是同一个函数</p>
<pre><code>parseInt(&quot;15&quot;, 10); == parseInt(&quot;15&quot;); //15
parseInt(&quot;Hello&quot;, 8); //NaN
parseInt(&quot;0e0&quot;, 16); //224
</code></pre><h2 id="7-Number-prototype-toExponential"><a href="#7-Number-prototype-toExponential" class="headerlink" title="7. Number.prototype.toExponential()"></a>7. Number.prototype.toExponential()</h2><p><strong>作用：</strong>以指数表示法返回该数值字符串表示形式<br><strong>语法：</strong>numObj.toExponential(fractionDigits)<br><strong>参数：</strong>fractionDigits: 可选。一个整数，用来指定小数点后有几位数字<br><strong>返回值：</strong>一个用幂的形式来表示Number 对象的字符串<br><strong>是否改变原对象：</strong>false<br><strong>兼容性：</strong>all<br><strong>版本：</strong>ES3<br><strong>描述：</strong><br>RangeError: (范围错误)<br>如果 fractionDigits 太小或太大将会抛出该错误。介于 0 和 20（包括20）之间的值不会引起 RangeError 。 执行环境也可以支持更大或更小范围。<br>TypeError: （类型错误）<br>如果该方法在一个非数值类型对象上调用。</p>
<pre><code>var numObj = 776666666.1234;;
alert(numObj.toExponential()); //输出 7.766666661234e+8
alert(numObj.toExponential(4)); //输出 7.7667e+8
alert(numObj.toExponential(2)); //输出 7.77e+8
alert(77.1234.toExponential()); //输出 7.71234e+1
alert(77 .toExponential()); //输出 7.7e+1
</code></pre><h2 id="8-Number-prototype-toFixed"><a href="#8-Number-prototype-toFixed" class="headerlink" title="8. Number.prototype.toFixed()"></a>8. Number.prototype.toFixed()</h2><p><strong>作用：</strong>使用定点表示法来格式化一个数<br><strong>语法：</strong>numObj.toFixed(digits)<br><strong>参数：</strong>小数点后数字的个数；介于 0 到 20 （包括）之间，实现环境可能支持更大范围。如果忽略该参数，则默认为 0。<br><strong>返回值：</strong>一个数值的字符串表现形式，不使用指数记数法，而是在小数点后有 digits 位数字<br><strong>是否改变原对象：</strong>false<br><strong>兼容性：</strong>all<br><strong>版本：</strong>ES3<br><strong>描述：</strong><br>RangeError:<br>如果 digits 参数太小或太大。0 到 20（包括）之间的值不会引起 RangeError。实现环境（implementations）也可以支持更大或更小的值。<br>TypeError:<br>如果该方法在一个非Number类型的对象上调用。</p>
<pre><code>var numObj = 12345.6789;

numObj.toFixed();         // 返回 &quot;12346&quot;：进行四舍五入，不包括小数部分
numObj.toFixed(1);        // 返回 &quot;12345.7&quot;：进行四舍五入
numObj.toFixed(6);        // 返回 &quot;12345.678900&quot;：用0填充
(1.23e+20).toFixed(2);    // 返回 &quot;123000000000000000000.00&quot;
(1.23e-10).toFixed(2);    // 返回 &quot;0.00&quot;
2.34.toFixed(1);          // 返回 &quot;2.3&quot;
-2.34.toFixed(1);         // 返回 -2.3 （由于操作符优先级，负数不会返回字符串）
(-2.34).toFixed(1);       // 返回 &quot;-2.3&quot; （若用括号提高优先级，则返回字符串）
</code></pre><h2 id="9-Number-prototype-toLocaleString"><a href="#9-Number-prototype-toLocaleString" class="headerlink" title="9. Number.prototype.toLocaleString()"></a>9. Number.prototype.toLocaleString()</h2><p><strong>作用：</strong>返回这个数字在特定语言环境下的表示字符串<br><strong>语法：</strong>numObj.toLocaleString(locales, options)<br><strong>参数：</strong>(详见MDN)</p>
<ul>
<li>locales: 可选.缩写语言代码的字符串或者这些字符串组成的数组<ul>
<li>nu: 要使用的编号系统。可能的值有: “arab”, “arabext”, “bali”, “beng”, “deva”, “fullwide”, “gujr”, “guru”, “hanidec”(中文十进制数字), “khmr”, “knda”, “laoo”, “latn”, “limb”, “mlym”, “mong”, “mymr”, “orya”, “tamldec”, “telu”, “thai”, “tibt”.</li>
</ul>
</li>
<li>options: 可选. 包含一些或所有的下面属性的类:<ul>
<li>localeMatcher: 使用的local的匹配算法</li>
<li>style: 格式化时使用的样式</li>
<li>currency: 在货币格式化中使用的货币符号</li>
<li>currencyDisplay: 如何在货币格式化中显示货币</li>
<li>useGrouping: 是否使用分组分隔符</li>
<li>minimumIntegerDigits: 使用的整数数字的最小数目</li>
<li>minimumFractionDigits: 使用的小数位数的最小数目</li>
<li>maximumFractionDigits: 使用的小数位数的最大数目</li>
<li>minimumSignificantDigits: 使用的有效数字的最小数目</li>
<li>maximumSignificantDigits: 使用的有效数字的最大数量</li>
</ul>
</li>
</ul>
<p><strong>返回值：</strong>返回一个语言环境下的表示字符串<br><strong>是否改变原对象：</strong>false<br><strong>兼容性：</strong>IE11+<br><strong>版本：</strong>ES3<br><strong>描述：</strong></p>
<pre><code>var numObj = 12345;

var a = numObj.toLocaleString();  
console.log(a);  //12,345
</code></pre><h2 id="10-Number-prototype-toPrecision"><a href="#10-Number-prototype-toPrecision" class="headerlink" title="10. Number.prototype.toPrecision()"></a>10. Number.prototype.toPrecision()</h2><p><strong>作用：</strong>以指定的精度返回该数值对象的字符串表示<br><strong>语法：</strong>numObj.toPrecision(precision)<br><strong>参数：</strong>precision: 可选，用来指定有效数个数的整数<br><strong>返回值：</strong>以定点表示法或指数表示法表示的一个数值对象的字符串<br><strong>是否改变原对象：</strong><br><strong>兼容性：</strong>all<br><strong>版本：</strong>ES3<br><strong>描述：</strong>如果忽略 precision 参数，则该方法表现类似于 Number.prototype.toString()。如果该参数是一个非整数值，将会向下舍入到最接近的整数。</p>
<pre><code>var numObj = 5.123456;
console.log(numObj.toPrecision());  //输出 5.123456
console.log(numObj.toPrecision(5)); //输出 5.1235
console.log(numObj.toPrecision(2)); //输出 5.1
console.log(numObj.toPrecision(1)); //输出 5
</code></pre><p>// 注意：在某些情况下会以指数表示法返回<br>console.log((1234.5).toPrecision(2)); // “1.2e+3”</p>
<h2 id="11-Number-prototype-toSource-————unstandard"><a href="#11-Number-prototype-toSource-————unstandard" class="headerlink" title="11. Number.prototype.toSource()————unstandard"></a>11. Number.prototype.toSource()————unstandard</h2><p><strong>作用：</strong>返回该对象源码的字符串表示<br><strong>语法：</strong>Number.toSource()<br><strong>参数：</strong>无<br><strong>返回值：</strong>该对象源码的字符串表示<br><strong>是否改变原对象：</strong>false<br><strong>兼容性：</strong>firefox<br><strong>版本：</strong>不是任何标准的一部分<br><strong>描述：</strong></p>
<pre><code>//firefox
var numObj = 5.123456;
console.log(numObj.toSource());  //(new Number(5.123456))
</code></pre><h2 id="12-Number-prototype-toString"><a href="#12-Number-prototype-toString" class="headerlink" title="12. Number.prototype.toString()"></a>12. Number.prototype.toString()</h2><p><strong>作用：</strong>返回指定 Number 对象的字符串表示形式<br><strong>语法：</strong>numObj.toString(radix)<br><strong>参数：</strong>radix: 转换基数，默认为10<br><strong>返回值：</strong>字符串表示形式<br><strong>是否改变原对象：</strong>false<br><strong>兼容性：</strong>all<br><strong>版本：</strong>ES1<br><strong>描述：</strong><br>RangeError<br>如果 toString() 的 radix 参数不在 2 到 36 之间，将会抛出一个 RangeError。</p>
<pre><code>var count = 10;

console.log(count.toString());    // 输出 &apos;10&apos;
console.log((17).toString());     // 输出 &apos;17&apos;
console.log((17.2).toString());   // 输出 &apos;17.2&apos;

var x = 6;

console.log(x.toString(2));       // 输出 &apos;110&apos;
console.log((254).toString(16));  // 输出 &apos;fe&apos;

console.log((-10).toString(2));   // 输出 &apos;-1010&apos;
console.log((-0xff).toString(2)); // 输出 &apos;-11111111&apos;
</code></pre><h2 id="13-Number-prototype-valueOf"><a href="#13-Number-prototype-valueOf" class="headerlink" title="13. Number.prototype.valueOf()"></a>13. Number.prototype.valueOf()</h2><p><strong>作用：</strong>返回一个被 Number 对象包装的原始值<br><strong>语法：</strong>numObj.valueOf()<br><strong>参数：</strong>无<br><strong>返回值：</strong>Number 对象的原始值<br><strong>是否改变原对象：</strong>false<br><strong>兼容性：</strong>all<br><strong>版本：</strong>ES1<br><strong>描述：</strong>该方法通常是由 JavaScript 引擎在内部隐式调用的，而不是由用户在代码中显式调用的</p>
<pre><code>var numObj = new Number(10);
console.log(typeof numObj); // object

var num = numObj.valueOf();
console.log(num);           // 10
console.log(typeof num);    // number
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/28/Function对象内置方法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godzhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/Function对象内置方法总结/" itemprop="url">Function对象内置方法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T20:42:46+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Function-prototype-apply"><a href="#1-Function-prototype-apply" class="headerlink" title="1. Function.prototype.apply()"></a>1. Function.prototype.apply()</h1><p>作用：调用一个函数，其具有指定的this值，以及作为一个数组提供的参数<br>语法：fn.apply(thisArg, [argsArray])<br>参数：</p>
<ul>
<li>thisArg: 在fn函数运行时指定的this值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。</li>
<li>argsArray: 一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。</li>
</ul>
<p>返回值：调用方法的返回值<br>兼容性：all<br>版本：ES3<br>描述：</p>
<pre><code>Function.prototype.construct = function(aArgs) {
  var fConstructor = this, fNewConstr = function() { 
    fConstructor.apply(this, aArgs); 
  };
  fNewConstr.prototype = fConstructor.prototype;
  return new fNewConstr();
};

function MyConstructor () {
    for (var nProp = 0; nProp &lt; arguments.length; nProp++) {
        this[&quot;property&quot; + nProp] = arguments[nProp];
    }
}

var myArray = [4, &quot;Hello world!&quot;, false];
var myInstance = MyConstructor.construct(myArray);

console.log(myInstance.property1);                // logs &quot;Hello world!&quot;
console.log(myInstance instanceof MyConstructor); // logs &quot;true&quot;
console.log(myInstance.constructor);              // logs &quot;MyConstructor&quot;

var numbers = [5, 6, 2, 3, 7];
var max = Math.max.apply(null, numbers); //7
var min = Math.min.apply(null, numbers); //2

var back;
function Fn(name, age){
    this.name = name;
    this.age = age;
    return 1;
}

function newFn(arr){
    back = Fn.apply(this, arr);
}

var fn = new newFn([&apos;zhangqi&apos;, 29]);
console.log(fn.name); //zhangqi
console.log(fn.age); //29
console.log(back); //1
</code></pre><h1 id="2-Function-prototype-bind"><a href="#2-Function-prototype-bind" class="headerlink" title="2. Function.prototype.bind()"></a>2. Function.prototype.bind()</h1><p>作用：创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。<br>语法：fn.bind(thisArg, arg1, arg2, …argN);<br>参数：</p>
<ul>
<li>thisArg: 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。</li>
<li>arg1, arg2, …argN: 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</li>
</ul>
<p>返回值：返回由指定的this值和初始化参数改造的原函数拷贝<br>兼容性：IE9+<br>版本：ES5<br>描述：</p>
<pre><code>//偏函数
function list(){
    return Array.prototype.slice.call(arguments);
}

var list1 = list(1,2,3); //[1,2,3]

var fn = list.bind(undefined, 37);//37会一直作为fn的第一个参数

console.log(fn()); // [37]
console.log(fn(1,2,3)) // [37,1,2,3]
</code></pre><h1 id="3-Function-prototype-call"><a href="#3-Function-prototype-call" class="headerlink" title="3. Function.prototype.call()"></a>3. Function.prototype.call()</h1><p>作用：同apply()方法<br>语法：fn.call(thisArg, arg1, arg2, …argN)<br>参数：arg1, arg2, …argN：参数列表<br>返回值：调用方法的返回值<br>兼容性：all<br>版本：ES1<br>描述：同apply方法的区别就是传参方式不同</p>
<pre><code>var back;
function Fn(name, age){
    this.name = name;
    this.age = age;
    return &apos;back&apos;;
}

function newFn(name, age){
    back = Fn.call(this, name, age);
}

var fn = new newFn(&apos;zhangqi&apos;, 29);
console.log(fn.name); //zhangqi
console.log(fn.age); //29
console.log(back); //back
</code></pre><h1 id="4-Function-prototype-isGenerator-————unstandard"><a href="#4-Function-prototype-isGenerator-————unstandard" class="headerlink" title="4. Function.prototype.isGenerator()————unstandard"></a>4. Function.prototype.isGenerator()————unstandard</h1><p>作用：判断一个函数是否是生成器<br>语法：fn.isGenerator()<br>参数：无<br>返回值：true || false<br>兼容性：—<br>版本：—<br>描述：—</p>
<pre><code>function f() {}
function* g() {
  yield 42;
}
console.log(f.isGenerator()); //false
console.log(g.isGenerator()); //true
</code></pre><h1 id="5-Function-prototype-toSource-————unstandard"><a href="#5-Function-prototype-toSource-————unstandard" class="headerlink" title="5. Function.prototype.toSource()————unstandard"></a>5. Function.prototype.toSource()————unstandard</h1><p>作用：返回函数的源代码的字符串表示<br>语法：fn.toSource()<br>参数：无<br>返回值：函数的源代码<br>兼容性：—<br>版本：—<br>描述：—</p>
<h1 id="6-Function-prototype-toString"><a href="#6-Function-prototype-toString" class="headerlink" title="6. Function.prototype.toString()"></a>6. Function.prototype.toString()</h1><p>作用：返回一个表示当前函数源代码的字符串<br>语法：fn.toString(indentation)<br>参数：indentation(Gecko 17 已废弃): 一个整数，表示反编译后的函数源代码应该增加几个空格作为额外的缩进。0为默认值，表示不增加任何额外缩进，-1或者其他负整数会让整个函数的源代码无任何缩进。<br>返回值：表示当前函数源代码的字符串<br>兼容性：all<br>版本：ES1<br>描述：Function 对象覆盖了从 Object 继承来的 Object.prototype.toString 方法。函数的 toString 方法会返回一个表示函数源代码的字符串。具体来说，包括 function关键字，形参列表，大括号，以及函数体中的内容。<br>在函数需要转换为字符串时，通常会自动调用函数的 toString 方法。</p>
<pre><code>function fn(){
    console.log(1);
}
console.log(fn.toString());
//function fn(){
//    console.log(1);
//}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/27/Date对象内置方法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godzhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/27/Date对象内置方法总结/" itemprop="url">Date对象内置方法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-27T22:50:23+08:00">
                2017-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Date-UTC"><a href="#1-Date-UTC" class="headerlink" title="1. Date.UTC()"></a>1. Date.UTC()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="2-Date-now"><a href="#2-Date-now" class="headerlink" title="2. Date.now()"></a>2. Date.now()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="3-Date-parse"><a href="#3-Date-parse" class="headerlink" title="3. Date.parse()"></a>3. Date.parse()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="4-Date-prototype-getDate"><a href="#4-Date-prototype-getDate" class="headerlink" title="4. Date.prototype.getDate()"></a>4. Date.prototype.getDate()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="5-Date-prototype-getDay"><a href="#5-Date-prototype-getDay" class="headerlink" title="5. Date.prototype.getDay()"></a>5. Date.prototype.getDay()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="6-Date-prototype-getFullYear"><a href="#6-Date-prototype-getFullYear" class="headerlink" title="6. Date.prototype.getFullYear()"></a>6. Date.prototype.getFullYear()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="7-Date-prototype-getHours"><a href="#7-Date-prototype-getHours" class="headerlink" title="7. Date.prototype.getHours()"></a>7. Date.prototype.getHours()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="8-Date-prototype-getMilliseconds"><a href="#8-Date-prototype-getMilliseconds" class="headerlink" title="8. Date.prototype.getMilliseconds()"></a>8. Date.prototype.getMilliseconds()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="9-Date-prototype-getMinutes"><a href="#9-Date-prototype-getMinutes" class="headerlink" title="9. Date.prototype.getMinutes()"></a>9. Date.prototype.getMinutes()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="10-Date-prototype-getMonth"><a href="#10-Date-prototype-getMonth" class="headerlink" title="10. Date.prototype.getMonth()"></a>10. Date.prototype.getMonth()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="11-Date-prototype-getSeconds"><a href="#11-Date-prototype-getSeconds" class="headerlink" title="11. Date.prototype.getSeconds()"></a>11. Date.prototype.getSeconds()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="12-Date-prototype-getTime"><a href="#12-Date-prototype-getTime" class="headerlink" title="12. Date.prototype.getTime()"></a>12. Date.prototype.getTime()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="13-Date-prototype-getTimezoneOffset"><a href="#13-Date-prototype-getTimezoneOffset" class="headerlink" title="13. Date.prototype.getTimezoneOffset()"></a>13. Date.prototype.getTimezoneOffset()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="14-Date-prototype-getUTCDate"><a href="#14-Date-prototype-getUTCDate" class="headerlink" title="14. Date.prototype.getUTCDate()"></a>14. Date.prototype.getUTCDate()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="15-Date-prototype-getUTCDay"><a href="#15-Date-prototype-getUTCDay" class="headerlink" title="15. Date.prototype.getUTCDay()"></a>15. Date.prototype.getUTCDay()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="16-Date-prototype-getUTCFullYear"><a href="#16-Date-prototype-getUTCFullYear" class="headerlink" title="16. Date.prototype.getUTCFullYear()"></a>16. Date.prototype.getUTCFullYear()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="17-Date-prototype-getUTCHours"><a href="#17-Date-prototype-getUTCHours" class="headerlink" title="17. Date.prototype.getUTCHours()"></a>17. Date.prototype.getUTCHours()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="18-Date-prototype-getUTCMilliseconds"><a href="#18-Date-prototype-getUTCMilliseconds" class="headerlink" title="18. Date.prototype.getUTCMilliseconds()"></a>18. Date.prototype.getUTCMilliseconds()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="19-Date-prototype-getUTCMinutes"><a href="#19-Date-prototype-getUTCMinutes" class="headerlink" title="19. Date.prototype.getUTCMinutes()"></a>19. Date.prototype.getUTCMinutes()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="20-Date-prototype-getUTCMonth"><a href="#20-Date-prototype-getUTCMonth" class="headerlink" title="20. Date.prototype.getUTCMonth()"></a>20. Date.prototype.getUTCMonth()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="21-Date-prototype-getUTCSeconds"><a href="#21-Date-prototype-getUTCSeconds" class="headerlink" title="21. Date.prototype.getUTCSeconds()"></a>21. Date.prototype.getUTCSeconds()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="22-Date-prototype-getYear"><a href="#22-Date-prototype-getYear" class="headerlink" title="22. Date.prototype.getYear()"></a>22. Date.prototype.getYear()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="23-Date-prototype-setDate"><a href="#23-Date-prototype-setDate" class="headerlink" title="23. Date.prototype.setDate()"></a>23. Date.prototype.setDate()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="24-Date-prototype-setFullYear"><a href="#24-Date-prototype-setFullYear" class="headerlink" title="24. Date.prototype.setFullYear()"></a>24. Date.prototype.setFullYear()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="25-Date-prototype-setHours"><a href="#25-Date-prototype-setHours" class="headerlink" title="25. Date.prototype.setHours()"></a>25. Date.prototype.setHours()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="26-Date-prototype-setMilliseconds"><a href="#26-Date-prototype-setMilliseconds" class="headerlink" title="26. Date.prototype.setMilliseconds()"></a>26. Date.prototype.setMilliseconds()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="27-Date-prototype-setMinutes"><a href="#27-Date-prototype-setMinutes" class="headerlink" title="27. Date.prototype.setMinutes()"></a>27. Date.prototype.setMinutes()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="28-Date-prototype-setMonth"><a href="#28-Date-prototype-setMonth" class="headerlink" title="28. Date.prototype.setMonth()"></a>28. Date.prototype.setMonth()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="29-Date-prototype-setSeconds"><a href="#29-Date-prototype-setSeconds" class="headerlink" title="29. Date.prototype.setSeconds()"></a>29. Date.prototype.setSeconds()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="30-Date-prototype-setTime"><a href="#30-Date-prototype-setTime" class="headerlink" title="30. Date.prototype.setTime()"></a>30. Date.prototype.setTime()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="31-Date-prototype-setUTCDate"><a href="#31-Date-prototype-setUTCDate" class="headerlink" title="31. Date.prototype.setUTCDate()"></a>31. Date.prototype.setUTCDate()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="32-Date-prototype-setUTCFullYear"><a href="#32-Date-prototype-setUTCFullYear" class="headerlink" title="32. Date.prototype.setUTCFullYear()"></a>32. Date.prototype.setUTCFullYear()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="33-Date-prototype-setUTCHours"><a href="#33-Date-prototype-setUTCHours" class="headerlink" title="33. Date.prototype.setUTCHours()"></a>33. Date.prototype.setUTCHours()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="34-Date-prototype-setUTCMilliseconds"><a href="#34-Date-prototype-setUTCMilliseconds" class="headerlink" title="34. Date.prototype.setUTCMilliseconds()"></a>34. Date.prototype.setUTCMilliseconds()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="35-Date-prototype-setUTCMinutes"><a href="#35-Date-prototype-setUTCMinutes" class="headerlink" title="35. Date.prototype.setUTCMinutes()"></a>35. Date.prototype.setUTCMinutes()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="36-Date-prototype-setUTCMonth"><a href="#36-Date-prototype-setUTCMonth" class="headerlink" title="36. Date.prototype.setUTCMonth()"></a>36. Date.prototype.setUTCMonth()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="37-Date-prototype-setUTCSeconds"><a href="#37-Date-prototype-setUTCSeconds" class="headerlink" title="37. Date.prototype.setUTCSeconds()"></a>37. Date.prototype.setUTCSeconds()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="38-Date-prototype-setYear"><a href="#38-Date-prototype-setYear" class="headerlink" title="38. Date.prototype.setYear()"></a>38. Date.prototype.setYear()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="39-Date-prototype-toDateString"><a href="#39-Date-prototype-toDateString" class="headerlink" title="39. Date.prototype.toDateString()"></a>39. Date.prototype.toDateString()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="40-Date-prototype-toGMTString"><a href="#40-Date-prototype-toGMTString" class="headerlink" title="40. Date.prototype.toGMTString()"></a>40. Date.prototype.toGMTString()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="41-Date-prototype-toISOString"><a href="#41-Date-prototype-toISOString" class="headerlink" title="41. Date.prototype.toISOString()"></a>41. Date.prototype.toISOString()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="42-Date-prototype-toJSON"><a href="#42-Date-prototype-toJSON" class="headerlink" title="42. Date.prototype.toJSON()"></a>42. Date.prototype.toJSON()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="43-Date-prototype-toLocaleDateString"><a href="#43-Date-prototype-toLocaleDateString" class="headerlink" title="43. Date.prototype.toLocaleDateString()"></a>43. Date.prototype.toLocaleDateString()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="44-Date-prototype-toLocaleFormat"><a href="#44-Date-prototype-toLocaleFormat" class="headerlink" title="44. Date.prototype.toLocaleFormat()"></a>44. Date.prototype.toLocaleFormat()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="45-Date-prototype-toLocaleString"><a href="#45-Date-prototype-toLocaleString" class="headerlink" title="45. Date.prototype.toLocaleString()"></a>45. Date.prototype.toLocaleString()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="46-Date-prototype-toLocaleTimeString"><a href="#46-Date-prototype-toLocaleTimeString" class="headerlink" title="46. Date.prototype.toLocaleTimeString()"></a>46. Date.prototype.toLocaleTimeString()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="47-Date-prototype-toSource"><a href="#47-Date-prototype-toSource" class="headerlink" title="47. Date.prototype.toSource()"></a>47. Date.prototype.toSource()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="48-Date-prototype-toString"><a href="#48-Date-prototype-toString" class="headerlink" title="48. Date.prototype.toString()"></a>48. Date.prototype.toString()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="49-Date-prototype-toTimeString"><a href="#49-Date-prototype-toTimeString" class="headerlink" title="49. Date.prototype.toTimeString()"></a>49. Date.prototype.toTimeString()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="50-Date-prototype-toUTCString"><a href="#50-Date-prototype-toUTCString" class="headerlink" title="50. Date.prototype.toUTCString()"></a>50. Date.prototype.toUTCString()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>
<h1 id="51-Date-prototype-valueOf"><a href="#51-Date-prototype-valueOf" class="headerlink" title="51. Date.prototype.valueOf()"></a>51. Date.prototype.valueOf()</h1><p>作用：<br>语法：<br>参数：<br>返回值：<br>是否改变原对象的值：<br>兼容性：<br>版本：<br>描述：</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/27/Javascript继承方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godzhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/27/Javascript继承方式/" itemprop="url">Javascript继承方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-27T20:51:12+08:00">
                2017-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>继承是面向对象编程中又一非常重要的概念，JavaScript支持实现继承，不支持接口继承，实现继承主要依靠原型链来实现的。</p>
<h1 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h1><p><em>实现思想：让一个原型对象指向另一个类型的实例</em></p>
<pre><code>function Fn(){
    this.property = true;
}
Fn.prototype.getProperty = function(){
    return this.property;
}

function newFn(){
    this.subproperty = &apos;zhangqi&apos;;
}
newFn.prototype = new Fn();

var instance = new newFn();
console.log(instance.getProperty()); //true
console.log(instance instanceof Fn); //true
console.log(instance.subproperty); //zhangqi
</code></pre><p>newFn继承了Fn，而继承是通过创建Fn的实例，并将该实例赋给newFn.prototype实现的<br>实现的本质是重写了newFn的原型对象，Fn的实例中的属性方法也存在于newFn.prototype中了</p>
<pre><code>原型链：
instance.__proto__ === newFn.prototype
newFn.prototype.__proto__ === Fn.prototype
</code></pre><h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><p>在给newFn原型添加方法或属性的时候，如果父类上也有同样的名字，newFn将会覆盖这个方法或属性，但这个方法或属性依然存在与父类中</p>
<pre><code>function Fn(){
    this.property = true;
}
Fn.prototype.getProperty = function(){
    return this.property;
}

function newFn(){
    this.subproperty = &apos;zhangqi&apos;;
}
newFn.prototype = new Fn();
//覆盖Fn中实例属性
newFn.prototype.property = &apos;newFn&apos;;

var instance = new newFn();
console.log(instance.getProperty()); //&apos;newFn&apos;
//覆盖Fn的getProperty方法
newFn.prototype.getProperty = function(){
    return this.subproperty;
}

console.log(instance.getProperty()); //&apos;zhangqi&apos;
</code></pre><p>不能以字面量的形式添加，否则等于又重写了newFn.prototype，会导致原型链截断</p>
<pre><code>function Fn(){
    this.property = true;
}
Fn.prototype.getProperty = function(){
    return this.property;
}

function newFn(){
    this.subproperty = &apos;zhangqi&apos;;
}
newFn.prototype = new Fn();

newFn.prototype = {
    getSubValue: function(){
        return this.subproperty;
    }
}

var instance = new newFn();
console.log(instance.getProperty()); 
//instance.getProperty is not a function
</code></pre><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>引用类型的属性被所有实例共享</p>
<pre><code>function Fn(){
    this.property = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];
}
Fn.prototype.getProperty = function(){
    return this.property;
}

function newFn(){
    this.subproperty = &apos;zhangqi&apos;;
}
newFn.prototype = new Fn();

var instance_1 = new newFn();
var instance_2 = new newFn();

instance_1.property.push(&apos;d&apos;,&apos;e&apos;);
console.log(instance_1.property);
console.log(instance_2.property);
</code></pre><p>newFn的所有实例都会共享property这个属性，修改其中一个引用类型值，会反映到其他实例中</p>
<h1 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2. 借用构造函数"></a>2. 借用构造函数</h1><p><em>实现思想：在子类构造函数内部调用父类构造函数，可以借助call和apply方法改变对象的执行上下文</em><br>此方法为了解决原型链继承中包含引用类型值所带来的问题</p>
<pre><code>function Fn(){
    this.property = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];
}

function newFn(){
    Fn.call(this);
}

var instance_1 = new newFn();
var instance_2 = new newFn();
var instance_3 = new Fn();

instance_1.property.push(&apos;d&apos;,&apos;e&apos;);
console.log(instance_1.property); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
console.log(instance_2.property); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
console.log(instance_3.property); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre><p>避免了引用类型的属性被所有实例共享</p>
<h3 id="可以在子类中向父类传参"><a href="#可以在子类中向父类传参" class="headerlink" title="可以在子类中向父类传参"></a>可以在子类中向父类传参</h3><pre><code>function Fn(name){
    this.name = name;
}

function newFn(name, age){
    Fn.call(this, name);
    this.age = age;
}

var instance_1 = new newFn(&apos;zhangqi&apos;);
var instance_2 = new newFn(&apos;tuqi&apos;);

console.log(instance_1.name); //zhangqi
console.log(instance_2.name); //tuqi
</code></pre><p>缺点：方法都在构造函数中定义，每次创建实例都会创建一遍方法，函数无法达到复用</p>
<h1 id="3-组合继承-原型链继承-构造函数继承"><a href="#3-组合继承-原型链继承-构造函数继承" class="headerlink" title="3. 组合继承(原型链继承+构造函数继承)"></a>3. 组合继承(原型链继承+构造函数继承)</h1><p><em>实现思想：使用原型链继承实现对原型属性和方法的继承，通过构造函数继承实现对实例属性的继承</em><br>既通过在原型上定义方法实现了复用，又能保证每个实例都有它自己的属性</p>
<pre><code>function Fn(name){
    this.name = name;
}
Fn.prototype.getProperty = function(){
    return this.property;
}

function newFn(name){
    Fn.call(this, name);
    this.property = &apos;newFn&apos;;
}
newFn.prototype = new Fn();

var instance_1 = new newFn(&apos;zhangqi&apos;);

console.log(instance_1.name); //zhangqi
console.log(instance_1.getProperty()); //newFn
</code></pre><p>这种模式避免了原型链和构造函数继承的缺陷，融合了他们的优点，是最常用的一种继承模式<br>这种模式会产生两组name属性，一组在newFn实例上，一组在newFn原型上<br>一次是在newFn.prototype = new Fn();<br>一次是在var instance_1 = new newFn(‘zhangqi’);<br>只不过实例上的屏蔽了原型上的</p>
<h1 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h1><p>可以基于已有的对象创建新对象，不必创建自定义类型<br>在object函数内部，先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。</p>
<pre><code>function Fn(name){
    this.property = true;
    this.name = name;
}
Fn.prototype.getProperty = function(){
    return this.property;
}
//封装方法
function object(obj){
    if(Object.create){
        return Object.create(obj);
    }else{
        function F(){};
        F.prototype = obj;
        return new F();
    }
}

var newFn = object(Fn.prototype);
newFn.property = false;
console.log(newFn.getProperty()); //false

function Fn(name){
    this.property = true;
    this.name = name;
}
Fn.prototype.getProperty = function(){
    return this.property;
}
//封装方法
function object(newObj, oldObj){
    if(Object.create){
        newObj.prototype = Object.create(oldObj);
    }else{
        function F(){};
        F.prototype = oldObj;
        newObj.prototype = new F();
    }
}

function newFn(name){
    Fn.call(this, name);
}

object(newFn, Fn.prototype);
var fn = new newFn(&apos;zhangqi&apos;);
console.log(fn.name); //zhangqi
console.log(fn.getProperty()); //true
</code></pre><p>缺点：所有实例都会共享属性，修改其中一个引用类型值，会反映到其他实例中</p>
<pre><code>var person = {
    name: &apos;zhangqi&apos;,
    arr: [1,2,3]
}

var a = Object.create(person);
a.arr.push(4,5);

console.log(a.arr);      //[1, 2, 3, 4, 5]
console.log(person.arr); //[1, 2, 3, 4, 5]
</code></pre><h1 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h1><p><em>实现思想：与寄生构造函数和工程模式类似，创建一个仅用于封装继承过程的函数</em></p>
<pre><code>function createAnother(o) {
  var clone = Object.create(o) // 创建一个新对象
  clone.sayHi = function() { // 添加方法
    console.log(&apos;hi&apos;)
  }
  return clone  // 返回这个对象
}
var person = {
  name: &apos;Jiang&apos;
}
var anotherPeson = createAnother(person)
anotherPeson.sayHi(); //hi
</code></pre><p>基于person返回了一个新对象anotherPeson，新对象不仅拥有了person的属性和方法，还有自己的sayHi方法。</p>
<p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法</p>
<h1 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h1><p>可以规避组合式继承产生两组属性的问题。<br>这种模式通过借用构造函数来继承属性，通过原型链的混成形式来继承方法<br><em>实现思路：不必为了指定子类型的原型而调用父类的构造函数，我们需要的无非就是父类原型的一个副本。</em><br>本质上就是使用寄生式继承来继承父类的原型，再将结果指定给子类型</p>
<p>function inheritPrototype(child, parent){<br>    var prototype = Object.create(parent.prototype);<br>    prototype.constructor = child;<br>    child.prototype = prototype;<br>}<br>1、创建父类型的副本<br>2、将创建的副本添加constructor属性<br>3、将子类的原型指向这个副本</p>
<pre><code>function SuperType(name) {
  this.name = name
  this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;]
}
SuperType.prototype.sayName = function () {
  console.log(this.name)
}
function SubType(name, job) {
  // 继承属性
  SuperType.call(this, name)

  this.job = job
}
// 继承
inheritPrototype(SubType, SuperType)
var instance = new SubType(&apos;Jiang&apos;, &apos;student&apos;)
instance.sayName()
</code></pre><p>直接使用Object.create来实现，其实就是将上面封装的函数拆开，这样演示可以更容易理解。</p>
<pre><code>function SuperType(name) {
  this.name = name
  this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;]
}
SuperType.prototype.sayName = function () {
  console.log(this.name)
}
function SubType(name, job) {
  // 继承属性
  SuperType.call(this, name)

  this.job = job
}
// 继承
SubType.prototype = Object.create(SuperType.prototype)
// 修复constructor
SubType.prototype.constructor = SubType
var instance = new SubType(&apos;Jiang&apos;, &apos;student&apos;)
instance.sayName()
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/26/String对象内置方法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godzhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/26/String对象内置方法总结/" itemprop="url">String对象内置方法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-26T21:40:53+08:00">
                2017-06-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-String-fromCharCode"><a href="#1-String-fromCharCode" class="headerlink" title="1. String.fromCharCode()"></a>1. String.fromCharCode()</h1><p>作用：静态 String.fromCharCode() 方法返回使用指定的Unicode值序列创建的字符串<br>语法：String.fromCharCode(num1, …, numN)<br>参数：num1, …, numN: 一组序列数字，表示Unicode值<br>返回值：新字符串<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES1<br>描述：为了处理所有的 Unicode 值（至 21 bits），只用 fromCharCode() 是不足的。由于高位编码字符是用两个低位编码（lower value）表示形成的一个字符，因此String.fromCodePoint()被用来返回这样一对低位编码，从而可以完全表示这些高位编码字符。</p>
<pre><code>var a = String.fromCharCode(65,66,67);
console.log(a);//ABC
</code></pre><h1 id="2-String-fromCodePoint"><a href="#2-String-fromCodePoint" class="headerlink" title="2. String.fromCodePoint()"></a>2. String.fromCodePoint()</h1><p>作用：String.fromCodePoint() 静态方法返回使用指定的代码点序列创建的字符串<br>语法：String.fromCodePoint(num1, …, numN)<br>参数：num1, …, numN: 一串Unicode编码<br>返回值：新字符串<br>是否改变原字符串：false<br>兼容性：IE- Safari-<br>版本：ES6<br>描述：因为 fromCodePoint()  是 String 的一个静态方法，所以只能通过 String.fromCodePoint() 这样的方式来使用，不能在你创建的 String 对象实例上直接调用。</p>
<pre><code>String.fromCodePoint(42);       // &quot;*&quot;
String.fromCodePoint(65, 90);   // &quot;AZ&quot;
String.fromCodePoint(0x404);    // &quot;\u0404&quot;
String.fromCodePoint(0x2F804);  // &quot;\uD87E\uDC04&quot;
String.fromCodePoint(194564);   // &quot;\uD87E\uDC04&quot;
String.fromCodePoint(0x1D306, 0x61, 0x1D307) // &quot;\uD834\uDF06a\uD834\uDF07&quot;

String.fromCodePoint(&apos;_&apos;);      // RangeError
String.fromCodePoint(Infinity); // RangeError
String.fromCodePoint(-1);       // RangeError
String.fromCodePoint(3.14);     // RangeError
String.fromCodePoint(3e-2);     // RangeError
String.fromCodePoint(NaN);      // RangeError
</code></pre><h1 id="3-String-prototype-anchor"><a href="#3-String-prototype-anchor" class="headerlink" title="3. String.prototype.anchor()"></a>3. String.prototype.anchor()</h1><p>作用：创建一个 <a> HTML 锚元素，被用作超文本靶标<br>语法：str.anchor(name)<br>参数：name: 一个字符串，表示被创建标签的name属性<br>返回值：创建的a标签(没有href属性)<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES6<br>描述：使用 anchor 方法创建的锚点（anchors）将会成为 document.anchors 数组的元素。</a></p>
<pre><code>var myString = &quot;Table of Contents&quot;;
document.body.innerHTML = myString.anchor(&quot;contents_anchor&quot;);
//&lt;a name=&quot;contents_anchor&quot;&gt;Table of Contents&lt;/a&gt;
console.log(document.anchors[0]);
//&lt;a name=&quot;contents_anchor&quot;&gt;Table of Contents&lt;/a&gt;
</code></pre><h1 id="4-String-prototype-charAt"><a href="#4-String-prototype-charAt" class="headerlink" title="4. String.prototype.charAt()"></a>4. String.prototype.charAt()</h1><p>作用：从一个字符串中返回指定的字符<br>语法：str.charAt(index)<br>参数：index: 默认为0，（index &gt;= 0 &amp;&amp; index &lt; str.length)的整数<br>      index &lt; 0 =&gt; 返回空(“”)<br>返回值：指定位置的字符<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES1<br>描述：</p>
<pre><code>var str = &apos;zhangqi&apos;;
var newStr = str.charAt( ); //z
var newStr = str.charAt(3); //n
</code></pre><h1 id="5-String-prototype-charCodeAt"><a href="#5-String-prototype-charCodeAt" class="headerlink" title="5. String.prototype.charCodeAt()"></a>5. String.prototype.charCodeAt()</h1><p>作用：从一个字符串中返回指定字符的Unicode编码<br>语法：str.charCodeAt(index)<br>参数：index : 和charAt()相同<br>返回值：表示给定索引处字符的 UTF-16 代码单元值的数字；如果索引超出范围，则返回 NaN。<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES1<br>描述：charCodeAt 总是返回一个小于 65,536 的值</p>
<pre><code>var str = &apos;zhangqi&apos;;
var a = str.charCodeAt(2); //97
var a = str.charCodeAt(20); //NaN
</code></pre><h1 id="6-String-prototype-codePointAt"><a href="#6-String-prototype-codePointAt" class="headerlink" title="6. String.prototype.codePointAt()"></a>6. String.prototype.codePointAt()</h1><p>作用：返回一个 Unicode 编码点值的非负整数<br>语法：str.codePointAt(pos)<br>参数：pos: 这个字符串中需要转码的元素的位置<br>返回值：在字符串中的给定索引的编码单元体现的数字，如果在索引处没找到元素则返回 undefined<br>是否改变原字符串：false<br>兼容性：IE11,safari-<br>版本：ES6<br>描述：如果在索引处开始没有UTF-16 代理对，将直接返回在那个索引处的编码单元。</p>
<pre><code>&apos;ABC&apos;.codePointAt(1);          // 66
&apos;\uD800\uDC00&apos;.codePointAt(0); // 65536
&apos;XYZ&apos;.codePointAt(42); // undefined
</code></pre><h1 id="7-String-prototype-concat"><a href="#7-String-prototype-concat" class="headerlink" title="7. String.prototype.concat()"></a>7. String.prototype.concat()</h1><p>作用：将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回<br>语法：str.concat(string2, string3, …stringN)<br>参数：string2, string3, …stringN: 和原字符串连接的多个字符串<br>返回值：新的字符串<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES3<br>描述：</p>
<pre><code>var str = &apos;zhangqi&apos;;
var a = str.concat(&apos;li&apos;,&apos;ul&apos;);
console.log(str); //&apos;zhangqi&apos;
console.log(a); //&apos;zhangqiliul&apos;
var b = String.prototype.concat.call(str,&apos;man&apos;);
console.log(b); //&apos;zhangqiman&apos;
</code></pre><h1 id="8-String-prototype-endsWith"><a href="#8-String-prototype-endsWith" class="headerlink" title="8. String.prototype.endsWith()"></a>8. String.prototype.endsWith()</h1><p>作用：用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的<br>语法：str.endsWith(searchString, position)<br>参数：</p>
<ul>
<li>searchString: 要搜索的子字符串</li>
<li>position: 在str中搜索searchString的结束位置，默认为str.length,也就是真正的字符串结尾处</li>
</ul>
<p>返回值：true || false<br>是否改变原字符串：false<br>兼容性：firefox,chrome,IE-<br>版本：ES6<br>描述：</p>
<pre><code>var str = &quot;To be, or not to be, that is the question.&quot;;
alert( str.endsWith(&quot;question.&quot;) );  // true
alert( str.endsWith(&quot;to be&quot;) );      // false
alert( str.endsWith(&quot;to be&quot;, 19) );  // true
alert( str.endsWith(&quot;To be&quot;, 5) );   // true
</code></pre><h1 id="9-String-prototype-includes"><a href="#9-String-prototype-includes" class="headerlink" title="9. String.prototype.includes()"></a>9. String.prototype.includes()</h1><p>作用：用于判断一个字符串是否包含在另一个字符串中<br>语法：str.includes(searchString, position)<br>参数：</p>
<ul>
<li>searchString: 要搜索的字符串</li>
<li>position: 寻找起始位置，默认为0。如果 position &lt; 0 则查找整个字符串（如同传进了 0）。如果 position &gt;= str.length，则该方法返回 false，除非被查找的字符串是一个空字符串，此时返回 false。</li>
</ul>
<p>返回值：true || false<br>是否改变原字符串：false<br>兼容性：IE-. opera-<br>版本：ES6<br>描述：—</p>
<pre><code>var str = &apos;To be, or not to be, that is the question.&apos;;
console.log(str.includes(&apos;To be&apos;));       // true
console.log(str.includes(&apos;question&apos;));    // true
console.log(str.includes(&apos;nonexistent&apos;)); // false
console.log(str.includes(&apos;To be&apos;, 1));    // false
console.log(str.includes(&apos;TO BE&apos;));       // false
</code></pre><h1 id="10-String-prototype-indexOf"><a href="#10-String-prototype-indexOf" class="headerlink" title="10. String.prototype.indexOf()"></a>10. String.prototype.indexOf()</h1><p>作用：返回调用  String 对象中第一次出现的指定值的索引，开始在 fromIndex进行搜索<br>语法：str.indexOf(searchValue, fromIndex);<br>参数：</p>
<ul>
<li>searchValue: 一个字符串表示被查找的值</li>
<li>fromIndex: 起始索引，默认为0,如果 fromIndex &lt; 0 则查找整个字符串（如同传进了 0）。如果 fromIndex &gt;= str.length，则该方法返回 -1，除非被查找的字符串是一个空字符串,如果fromIndex &lt; str.length,返回fromIndex，否则返回 str.length。</li>
</ul>
<p>返回值：指定值的第一次出现的索引; 如果没有返回 -1<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES1<br>描述：indexOf 方法区分大小写</p>
<pre><code>&quot;Blue Whale&quot;.indexOf(&quot;Blue&quot;);     // returns  0
&quot;Blue Whale&quot;.indexOf(&quot;Blute&quot;);    // returns -1
&quot;Blue Whale&quot;.indexOf(&quot;Whale&quot;, 0); // returns  5
&quot;Blue Whale&quot;.indexOf(&quot;Whale&quot;, 5); // returns  5
&quot;Blue Whale&quot;.indexOf(&quot;&quot;, 9);      // returns  9
&quot;Blue Whale&quot;.indexOf(&quot;&quot;, 10);     // returns 10
&quot;Blue Whale&quot;.indexOf(&quot;&quot;, 11);     // returns 10
</code></pre><h1 id="11-String-prototype-lastIndexOf"><a href="#11-String-prototype-lastIndexOf" class="headerlink" title="11. String.prototype.lastIndexOf()"></a>11. String.prototype.lastIndexOf()</h1><p>作用：返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。从该字符串的后面向前查找，从 fromIndex 处开始<br>语法：str.lastIndexOf(searchValue, fromIndex)<br>参数：</p>
<ul>
<li>searchValue: 一个字符串表示被查找的值</li>
<li>fromIndex: 可以是任意整数。默认值为 str.length。如果为负值，则被看作 0。如果 fromIndex &gt; str.length，则 fromIndex 被看作 str.length。</li>
</ul>
<p>返回值：指定值的最后出现的索引; 如果没有返回 -1<br>是否改变原字符串：<br>兼容性：all<br>版本：ES1<br>描述：区分大小写</p>
<pre><code>&quot;canal&quot;.lastIndexOf(&quot;a&quot;)   // returns 3
&quot;canal&quot;.lastIndexOf(&quot;a&quot;,2) // returns 1
&quot;canal&quot;.lastIndexOf(&quot;a&quot;,0) // returns -1
&quot;canal&quot;.lastIndexOf(&quot;x&quot;)   // returns -1
</code></pre><h1 id="12-String-prototype-link"><a href="#12-String-prototype-link" class="headerlink" title="12. String.prototype.link()"></a>12. String.prototype.link()</h1><p>作用：创建一个 <a> HTML 元素，用该字符串作为超链接的显示文本，参数作为指向另一个 URL 的超链接。<br>语法：str.link(url)<br>参数：url: 任何能够指定 a 标签的 href 属性的字符串；它应当是有效的 URL（相对或绝对），任何 &amp; 字符将会被转义为 &amp;，任何 “ 字符将会被转义为 &quot;。<br>返回值：创建好的a标签<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES6<br>描述：使用 link 方法创建一个超链接 HTML 片段。返回的字符串可以通过 document.write 或 element.innerHTML 方法添加到文档中。<br>使用 link 方法创建的链接将会成为 document.links 数组中的元素。</a></p>
<pre><code>var hotText = &quot;MDN&quot;;
var URL = &quot;https://developer.mozilla.org/&quot;;
document.body.innerHTML = hotText.link(URL));
//&lt;a href=&quot;https://developer.mozilla.org/&quot;&gt;MDN&lt;/a&gt;
</code></pre><h1 id="13-String-prototype-localeCompare"><a href="#13-String-prototype-localeCompare" class="headerlink" title="13. String.prototype.localeCompare()"></a>13. String.prototype.localeCompare()</h1><p>作用：返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。<br>语法：referenceStr.localeCompare(compareString, locales, options)<br>参数：</p>
<ul>
<li>compareString: 用来比较的字符串</li>
<li>locales: 用来比较的语言</li>
<li>options: 影响结果的参数</li>
</ul>
<p>返回值：+num, 0, -num<br>是否改变原字符串：false<br>兼容性：safari-,IE11+<br>版本：ES3<br>描述：返回一个数字表示是否 引用字符串 在排序中位于 比较字符串 的前面，后面，或者二者相同。<br>当 引用字符串 在 比较字符串 前面时返回 -1<br>当 引用字符串 在 比较字符串 后面时返回 1<br>相同位置时返回 0<br>切勿依赖于 -1 或 1 这样特定的返回值。不同浏览器之间（以及不同浏览器版本之间） 返回的正负数的值各有不同，因为W3C规范中只要求返回值是正值和负值，而没有规定具体的值。一些浏览器可能返回-2或2或其他一些负的、正的值。</p>
<pre><code>// &apos;a&apos;排在&apos;c&apos;前面
&apos;a&apos;.localeCompare(&apos;c&apos;); 
// -2 or -1 (or some other negative value)

// &apos;a&apos;排在&apos;c&apos;后面
&apos;check&apos;.localeCompare(&apos;against&apos;); 
// 2 or 1 (or some other positive value)

// &quot;a&quot; and &quot;a&quot; are equivalent yielding a neutral value of zero
&apos;a&apos;.localeCompare(&apos;a&apos;); 
// 0
</code></pre><h1 id="14-String-prototype-match"><a href="#14-String-prototype-match" class="headerlink" title="14. String.prototype.match()"></a>14. String.prototype.match()</h1><p>作用：当一个字符串与一个正则表达式匹配时， match()方法检索匹配项<br>语法：str.match(regexp)<br>参数：regexp: 一个正则表达式对象如果传入一个非正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp 。如果你未提供任何参数，直接使用 match() ，那么你会得到一个包含空字符串的 Array ：[“”] 。<br>返回值：一个包含了整个匹配结果以及任何括号捕获的匹配结果的 Array ；如果没有匹配项，则返回 null<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES3<br>描述：如果正则表达式没有 g 标志，则 str.match() 会返回和 RegExp.exec() 相同的结果。而且返回的 Array 拥有一个额外的 input 属性，该属性包含被解析的原始字符串。另外，还拥有一个 index 属性，该属性表示匹配结果在原字符串中的索引（以0开始）。<br>如果正则表达式包含 g 标志，则该方法返回一个 Array ，它包含所有匹配的子字符串而不是匹配对象。捕获组不会被返回。如果没有匹配到，则返回  null 。</p>
<pre><code>var reg = /an/g;
var str = &apos;zhangqi&apos;;
console.log(str.match(reg)); //[&quot;an&quot;]
console.log(str.match());    //[&quot;&quot;, index: 0, input: &quot;zhangqi&quot;]
console.log(str.match(&apos;an&apos;));//[&quot;an&quot;, index: 2, input: &quot;zhangqi&quot;]
console.log(str.match(/za/g));//null

var str = &apos;For more information, see Chapter 3.4.5.1&apos;;
var re = /see (chapter \d+(\.\d)*)/i;
var found = str.match(re);

console.log(found);
//[ &apos;see Chapter 3.4.5.1&apos;,
//&apos;Chapter 3.4.5.1&apos;,
//&apos;.1&apos;,
//index: 22,
//input: &apos;For more information, see Chapter 3.4.5.1&apos; ]
</code></pre><h1 id="15-String-prototype-normalize"><a href="#15-String-prototype-normalize" class="headerlink" title="15. String.prototype.normalize()"></a>15. String.prototype.normalize()</h1><p>作用：按照指定的一种 Unicode 正规形式将当前字符串正规化<br>语法：str.normalize([form])<br>参数：form: 四种正规形式: NFC, NFD, NFKC, NFKD  默认为NFC<br>返回值：正规化后的字符串<br>是否改变原字符串：true<br>兼容性：IE-,Opera-, Safari-<br>版本：ES6<br>描述：如果给 form 传入了非法的参数值, 则会抛出 RangeError 异常.</p>
<pre><code>var str = &quot;\u1E9B\u0323&quot;;
str.normalize(); // &quot;\u1E9B\u0323&quot;
str.normalize(&quot;NFD&quot;); // &quot;\u017F\u0323\u0307&quot;
str.normalize(&quot;NFKC&quot;); // &quot;\u1E69&quot;
str.normalize(&quot;NFKD&quot;); // &quot;\u0073\u0323\u0307&quot;
</code></pre><h1 id="16-String-prototype-padEnd-————expering"><a href="#16-String-prototype-padEnd-————expering" class="headerlink" title="16. String.prototype.padEnd()————expering"></a>16. String.prototype.padEnd()————expering</h1><p>作用：用第二个参数中指定的填充字符串，在当前字符串的尾部不断填充，直到它达到第一个参数中指定的目标长度。<br>语法：str.padEnd(targetLength, padString)<br>参数：</p>
<ul>
<li>targetLength: 当前字符串需要填充到的目标长度。如果当前字符串原本就达到了该长度，那么该方法什么都不会做，直接返回原字符串。</li>
<li>padString: 填充字符串。如果在填充过程中发现用不完这一整个填充字符串，则优先用左侧部分，能用多少用多少。该参数为可选参数，默认值为空格 “ “</li>
</ul>
<p>返回值：在原字符串尾部填充指定的填充字符串直到目标长度所形成的新字符串<br>是否改变原字符串：false<br>兼容性：firefox,chrome<br>版本：仍是ECMAScript提案<br>描述：—</p>
<pre><code>&apos;abc&apos;.padEnd(10);         // &quot;abc       &quot;
&apos;abc&apos;.padEnd(10, &quot;foo&quot;);  // &quot;abcfoofoof&quot;
&apos;abc&apos;.padEnd(6,&quot;123465&quot;); // &quot;abc123&quot;
</code></pre><h1 id="17-String-prototype-padStart-————expering"><a href="#17-String-prototype-padStart-————expering" class="headerlink" title="17. String.prototype.padStart()————expering"></a>17. String.prototype.padStart()————expering</h1><p>作用：用第二个参数中指定的填充字符串，在当前字符串的头部不断填充，直到它达到第一个参数中指定的目标长度<br>语法：str.padStart(targetLength, padString)<br>参数：</p>
<ul>
<li>targetLength: 当前字符串需要填充到的目标长度。如果当前字符串原本就达到了该长度，那么该方法什么都不会做，直接返回原字符串。</li>
<li>padString: 填充字符串。如果在填充过程中发现用不完这一整个填充字符串，则优先用左侧部分，能用多少用多少。该参数为可选参数，默认值为空格 “ “</li>
</ul>
<p>返回值：在原字符串开头填充指定的填充字符串直到目标长度所形成的新字符串<br>是否改变原字符串：false<br>兼容性：firefox,chrome<br>版本：仍是ECMAScript提案<br>描述：</p>
<pre><code>&apos;abc&apos;.padStart(10);         // &quot;       abc&quot;
&apos;abc&apos;.padStart(10, &quot;foo&quot;);  // &quot;foofoofabc&quot;
&apos;abc&apos;.padStart(6,&quot;123465&quot;); // &quot;123abc&quot;
</code></pre><h1 id="18-String-prototype-repeat"><a href="#18-String-prototype-repeat" class="headerlink" title="18. String.prototype.repeat()"></a>18. String.prototype.repeat()</h1><p>作用：构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本<br>语法：let resultString = str.repeat(count);<br>参数：count: [0, 正无穷)表示在新构造的字符串中重复了多少遍原字符串<br>返回值：包含指定字符串的指定数量副本的新字符串<br>是否改变原字符串：false<br>兼容性：IE-,Opera-<br>版本：ES6<br>描述：RangeError: 重复次数不能为负数。<br>      RangeError: 重复次数必须小于 infinity，且长度不会大于最长的字符串。</p>
<pre><code>&quot;abc&quot;.repeat(-1) // RangeError: repeat count must be positive and less than inifinity
&quot;abc&quot;.repeat(0)  // &quot;&quot;
&quot;abc&quot;.repeat(1)  // &quot;abc&quot;
&quot;abc&quot;.repeat(2)  // &quot;abcabc&quot;
&quot;abc&quot;.repeat(3.5)// &quot;abcabcabc&quot; 参数count将会被自动转换成整数.
&quot;abc&quot;.repeat(1/0)// RangeError: repeat count must be positive and less than inifinity
</code></pre><h1 id="19-String-prototype-replace"><a href="#19-String-prototype-replace" class="headerlink" title="19. String.prototype.replace()"></a>19. String.prototype.replace()</h1><p>作用：返回一个由替换值替换一些或所有匹配的的模式后的新字符串<br>语法：str.replace(regexp|substr, newSubStr|function)<br>参数：</p>
<ul>
<li>regexp: 一个 RegExp 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉</li>
<li><p>substr: 一个要被 newSubStr 替换的字符串。其被视为一整个字符串，而不是一个正则表达式。仅仅是第一个匹配会被替换。</p>
<ul>
<li>$$: 插入一个 “$”</li>
<li>$&amp;: 插入匹配的子串</li>
<li>$`: 插入当前匹配的子串左边的内容</li>
<li>$\’: 插入当前匹配的子串右边的内容</li>
<li>$n: 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。</li>
</ul>
</li>
<li><p>newSubStr: 用于替换掉第一个参数在原字符串中的匹配部分的 字符串</p>
</li>
<li>function: 一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。</li>
</ul>
<p>返回值：一个部分或全部匹配由替代模式所取代的新的字符串<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES3<br>描述：</p>
<pre><code>var str = &apos;zhangqi&apos;;
var a = str.replace(&apos;an&apos;,&apos;q$q&apos;); //zhq$agqi
var a = str.replace(&apos;an&apos;,&apos;q$$q&apos;);//同上
var a = str.replace(&apos;an&apos;,&apos;q$&amp;q&apos;); //zhqanqgqi
var a = str.replace(&apos;an&apos;,&apos;q$`q&apos;); //zhqzhqgqi
var a = str.replace(&apos;an&apos;,&apos;q$\&apos;q&apos;);//zhqgqiqgqi

//function参数说明
function replacer(match, p1, p2, p3, offset, string){
    //match: 匹配的子串
    //p1,p2,p3: 匹配的子项
    //offset: 匹配到的子字符串在原字符串中的偏移量（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1）
    //string: 被匹配的原字符串
    return [p1, p2, p3].join(&apos;-&apos;);
}
var newString = &apos;abc12345#$*%&apos;.replace(/([^\d]*)(\d*)([^\w]*)/, replacer);
//abc-12345-#$*%

//交换字符串中的两个单词
var re = /(\w+)\s(\w+)/;
var str = &quot;John Smith&quot;;
var newstr = str.replace(re, &quot;$2, $1&quot;);
console.log(newstr);// Smith, John
</code></pre><h1 id="20-String-prototype-search"><a href="#20-String-prototype-search" class="headerlink" title="20. String.prototype.search()"></a>20. String.prototype.search()</h1><p>作用：执行正则表达式和 String对象之间的一个搜索匹配<br>语法：str.search(regexp)<br>参数：regexp: 一个正则表达式对象。如果传入一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象。<br>返回值：如果匹配成功，则 search() 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES3<br>描述：当你想要知道字符串中是否存在某个模式（pattern）时可使用 search，类似于正则表达式的 test 方法。当要了解更多匹配信息时，可使用 match（会更慢），该方法类似于正则表达式的 exec 方法。</p>
<pre><code>var str = &apos;zhangqi&apos;;
var reg = /an/g;
var result = str.search(reg); //2
var result = str.search();    //0
var result = str.search(/za/g);//-1

function testinput(re, str){
  var midstring;
  if (str.search(re) != -1){
    midstring = &quot; contains &quot;;
  } else {
    midstring = &quot; does not contain &quot;;
  }
  console.log (str + midstring + re);
}
</code></pre><h1 id="21-String-prototype-slice"><a href="#21-String-prototype-slice" class="headerlink" title="21. String.prototype.slice()"></a>21. String.prototype.slice()</h1><p>作用：提取一个字符串的一部分，并返回一个新的字符串<br>语法：str.slice(beginSlice, endSlice)<br>参数：</p>
<ul>
<li>beginSlice: 起始索引 beginSlice &lt; 0 ? str.length + beginSlice</li>
<li>endSlice: 结束索引 endSlice &lt; 0 ? str.length + endSlice</li>
</ul>
<p>返回值：提取后的新字符串<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES3<br>描述：</p>
<pre><code>var str1 = &apos;The morning is upon us.&apos;;
var str2 = str1.slice(); //The morning is upon us.不写参数全部提取
var str2 = str1.slice(4, -2);// morning is upon u

var str = &apos;The morning is upon us.&apos;;
str.slice(-3);     // &apos;us.&apos;
str.slice(-3, -1); // &apos;us&apos;
str.slice(0, -1);  // &apos;The morning is upon us&apos;
</code></pre><h1 id="22-String-prototype-split"><a href="#22-String-prototype-split" class="headerlink" title="22. String.prototype.split()"></a>22. String.prototype.split()</h1><p>作用：将一个字符串分割成字符串数组<br>语法：str.split(separator, limit)<br>参数：</p>
<ul>
<li>separator: 指定用来分割字符串的字符（串）。separator 可以是一个字符串或正则表达式。 如果忽略 separator，则返回整个字符串的数组形式。如果 separator 是一个空字符串，则 str 将会把原字符串中每个字符的数组形式返回。</li>
<li>limit: 一个整数，限定返回的分割片段数量。split 方法仍然分割每一个匹配的 separator，但是返回的数组只会截取最多 limit 个元素。</li>
</ul>
<p>返回值：返回分割后的一个数组<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES3<br>描述：</p>
<pre><code>var str = &apos;zhangqi&apos;;
var a = str.split();  //[&quot;zhangqi&quot;]
var a = str.split(&quot;a&quot;); //[&quot;zh&quot;, &quot;ngqi&quot;]
var a = str.split(&quot;a&quot;, 1); //[&quot;zh&quot;]
var a = str.split(&quot;&quot;); //[&quot;z&quot;, &quot;h&quot;, &quot;a&quot;, &quot;n&quot;, &quot;g&quot;, &quot;q&quot;, &quot;i&quot;]
var a = &quot;&quot;.split(&quot;&quot;); //空数组[]
var a = &quot;&quot;.split(&quot;a&quot;);//[&quot;&quot;]包含空字符串的数组,length=1

//移出字符串中的空格
var names = &quot;Harry Trump ;Fred Barney; Helen Rigby ; Bill Abel ;Chris Hand &quot;;
var re = /\s*;\s*/;
var nameList = names.split(re);
console.log(nameList);//[Harry Trump,Fred Barney,Helen Rigby,Bill Abel,Chris Hand]

var myString = &quot;Hello 1 word. Sentence number 2.&quot;;
var splits = myString.split(/(\d)/);
console.log(splits);//[&quot;Hello &quot;, &quot;1&quot;, &quot; word. Sentence number &quot;, &quot;2&quot;, &quot;.&quot;]
</code></pre><h1 id="23-String-prototype-startsWith"><a href="#23-String-prototype-startsWith" class="headerlink" title="23. String.prototype.startsWith()"></a>23. String.prototype.startsWith()</h1><p>作用：用来判断当前字符串是否是以另外一个给定的子字符串“开头”的<br>语法：str.startsWith(searchString, position)<br>参数：</p>
<ul>
<li>searchString: 要搜索的子字符串</li>
<li>position: 在str中搜索searchString的开始位置，默认为0,也就是真正的字符串开头处</li>
</ul>
<p>返回值：true || false<br>是否改变原字符串：false<br>兼容性：IE-<br>版本：ES6<br>描述：</p>
<pre><code>var str = &quot;To be, or not to be, that is the question.&quot;;
alert(str.startsWith(&quot;To be&quot;));         // true
alert(str.startsWith(&quot;not to be&quot;));     // false
alert(str.startsWith(&quot;not to be&quot;, 10)); // true
</code></pre><h1 id="24-String-prototype-substr"><a href="#24-String-prototype-substr" class="headerlink" title="24. String.prototype.substr()"></a>24. String.prototype.substr()</h1><p>作用：返回一个字符串中从指定位置开始到指定字符数的字符<br>语法：str.substr(start, length)<br>参数：</p>
<ul>
<li>start: 起始索引 start &lt; 0 ? str.length + start 默认为0</li>
<li>length: 可选，提取的字符数</li>
</ul>
<p>返回值：新的字符串<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES3<br>描述：如果 start 为正值，且大于或等于字符串的长度，则 substr 返回一个空字符串。<br>      如果 length 为 0 或负值，则 substr 返回一个空字符串。如果忽略 length，则 substr 提取字符，直到字符串末尾。</p>
<pre><code>var str = &quot;abcdefghij&quot;;
console.log(&quot;(1,2): &quot;    + str.substr(1,2));   // (1,2): bc
console.log(&quot;(-3,2): &quot;   + str.substr(-3,2));  // (-3,2): hi
console.log(&quot;(-3): &quot;     + str.substr(-3));    // (-3): hij
console.log(&quot;(1): &quot;      + str.substr(1));     // (1): bcdefghij
console.log(&quot;(-20, 2): &quot; + str.substr(-20,2)); // (-20, 2): ab
console.log(&quot;(20, 2): &quot;  + str.substr(20,2));  // (20, 2):
</code></pre><h1 id="25-String-prototype-substring"><a href="#25-String-prototype-substring" class="headerlink" title="25. String.prototype.substring()"></a>25. String.prototype.substring()</h1><p>作用：返回一个字符串在开始索引到结束索引之间的一个子集，或从开始索引直到字符串的末尾的一个子集<br>语法：str.substring(indexStart, indexEnd)<br>参数：</p>
<ul>
<li>indexStart: 起始索引 indexStart &lt; 0 ? 0 |indexStart &gt; str.length ? str.length</li>
<li>indexEnd: 可选，结束索引 indexEnd &lt; 0 ? 0 |indexEnd &gt; str.length ? str.length</li>
</ul>
<p>返回值：新的字符（串）<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES1<br>描述：<br>如果 indexStart 等于 indexEnd，substring 返回一个空字符串。<br>如果省略 indexEnd，substring 提取字符一直到字符串末尾。<br>如果任一参数小于 0 或为 NaN，则被当作 0。<br>如果任一参数大于 stringName.length，则被当作 stringName.length。<br>如果 indexStart 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样。例如，str.substring(1, 0) == str.substring(0, 1)。</p>
<pre><code>var str = &apos;zhangqi&apos;;
var a = str.substring(3,0); //zha
var a = str.substring(3,3); //&quot;&quot;
var a = str.substring(3);   //ngqi
var a = str.substring(3,-3);//zha
var a = str.substring(-3);  //zhangqi
var a = str.substring(10);  //&quot;&quot;
var a = str.substring(2,15);//angqi
</code></pre><h1 id="26-String-prototype-toLocaleLowerCase"><a href="#26-String-prototype-toLocaleLowerCase" class="headerlink" title="26. String.prototype.toLocaleLowerCase()"></a>26. String.prototype.toLocaleLowerCase()</h1><p>作用：根据任何特定于语言环境的案例映射，返回调用字符串值转换为小写的值<br>语法：str.toLocaleLowerCase()<br>参数：无<br>返回值：根据任何特定于语言环境的案例映射，将表示调用字符串的新字符串转换为小写<br>是否改变原字符串：false<br>兼容性：ES3<br>版本：all<br>描述：大多数情况下，这个方法与 toLowerCase() 会产生相同的值，但是对于一些语言（locale）,例如土耳其语，因为它们的大小写映射规则与Unicode默认的映射规则不同，所以调用这两个方法将会产生不同的结果。</p>
<pre><code>console.log(&apos;ALPHABET&apos;.toLocaleLowerCase()); 
// &apos;alphabet&apos;
console.log(&apos;中文简体 zh-CN || zh-Hans&apos;.toLocaleLowerCase());
// &apos;中文简体 zh-cn || zh-hans&apos;
</code></pre><h1 id="27-String-prototype-toLocaleUpperCase"><a href="#27-String-prototype-toLocaleUpperCase" class="headerlink" title="27. String.prototype.toLocaleUpperCase()"></a>27. String.prototype.toLocaleUpperCase()</h1><p>作用：使用本地化的大小写映射规则将输入的字符串转化成大写形式并返回结果字符串<br>语法：str.toLocaleUpperCase()<br>参数：无<br>返回值：一个新的字符串，即根据本地化的大小写映射规则将输入的字符串转化成大写形式的结果<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES3<br>描述：大多数情况下，这个方法与 toUpperCase() 会产生相同的值，但是对于一些语言（locale）,例如土耳其语，因为它们的大小写映射规则与Unicode默认的映射规则不同，所以调用这两个方法将会产生不同的结果。</p>
<pre><code>console.log(&apos;alphabet&apos;.toLocaleUpperCase()); // &apos;ALPHABET&apos;
</code></pre><h1 id="28-String-prototype-toLowerCase"><a href="#28-String-prototype-toLowerCase" class="headerlink" title="28. String.prototype.toLowerCase()"></a>28. String.prototype.toLowerCase()</h1><p>作用：将调用该方法的字符串值转为小写形式，并返回<br>语法：str.toLowerCase()<br>参数：无<br>返回值：转换为小写后的新字符串<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES1<br>描述：</p>
<pre><code>console.log(&apos;中文简体 zh-CN || zh-Hans&apos;.toLowerCase());
// 中文简体 zh-cn || zh-hans
​console.log( &quot;ALPHABET&quot;.toLowerCase() ); 
// &quot;alphabet&quot;
</code></pre><h1 id="29-String-prototype-toSource-——————unstandard"><a href="#29-String-prototype-toSource-——————unstandard" class="headerlink" title="29. String.prototype.toSource()——————unstandard"></a>29. String.prototype.toSource()——————unstandard</h1><p>作用：返回一个代表对象的源代码<br>语法：str.toSource || String.toSource<br>参数：无<br>返回值：代表对象的源代码<br>是否改变原字符串：false<br>兼容性：仅火狐支持<br>版本：不属于任何规范<br>描述：</p>
<pre><code>//火狐下
var str = &apos;ZHANGqi&apos;;
var a = str.toSource();
console.log(str); //ZHANGqi
console.log(a);   //(new String(&quot;ZHANGqi&quot;))
</code></pre><h1 id="30-String-prototype-toString"><a href="#30-String-prototype-toString" class="headerlink" title="30. String.prototype.toString()"></a>30. String.prototype.toString()</h1><p>作用：返回指定对象的字符串形式<br>语法：str.toString()<br>参数：无<br>返回值：指定对象的字符串形式<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES1<br>描述：String 对象覆盖了Object 对象的 toString 方法；并没有继承 Object.toString()。对于 String 对象，toString 方法返回该对象的字符串形式，和 String.prototype.valueOf() 方法返回值一样。</p>
<pre><code>var x = new String(&quot;Hello world&quot;);
alert(x.toString())      // 输出 &quot;Hello world&quot;
</code></pre><h1 id="31-String-prototype-toUpperCase"><a href="#31-String-prototype-toUpperCase" class="headerlink" title="31. String.prototype.toUpperCase()"></a>31. String.prototype.toUpperCase()</h1><p>作用：将调用该方法的字符串值转换为大写形式，并返回<br>语法：str.toUpperCase()<br>参数：无<br>返回值：转换为大写后的新字符串<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES1<br>描述：</p>
<pre><code>​console.log( &quot;alphabet&quot;.toUpperCase() ); // &quot;ALPHABET&quot;
</code></pre><h1 id="32-String-prototype-trim"><a href="#32-String-prototype-trim" class="headerlink" title="32. String.prototype.trim()"></a>32. String.prototype.trim()</h1><p>作用：从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。<br>语法：str.trim()<br>参数：无<br>返回值：去掉两端空白字符的新字符串<br>是否改变原字符串：false<br>兼容性：IE9+<br>版本：ES5<br>描述：</p>
<pre><code>var orig = &apos;   foo  &apos;;
console.log(orig.trim()); // &apos;foo&apos;
var orig = &apos;foo    &apos;;
console.log(orig.trim()); // &apos;foo&apos;
</code></pre><h1 id="33-String-prototype-trimLeft-——————unstandard"><a href="#33-String-prototype-trimLeft-——————unstandard" class="headerlink" title="33. String.prototype.trimLeft()——————unstandard"></a>33. String.prototype.trimLeft()——————unstandard</h1><p>作用：从一个字符串的左端移除空白字符<br>语法：str.trimLeft()<br>参数：无<br>返回值：去掉左端空白字符的新字符串<br>是否改变原字符串：false<br>兼容性：chrome, firefox<br>版本：无相关规范<br>描述：</p>
<pre><code>var str = &quot;   foo  &quot;;
alert(str.length); // 8
str = str.trimLeft();
alert(str.length); // 5
alert( str ); //&quot;foo  &quot;
</code></pre><h1 id="34-String-prototype-trimRight-——————unstandard"><a href="#34-String-prototype-trimRight-——————unstandard" class="headerlink" title="34. String.prototype.trimRight()——————unstandard"></a>34. String.prototype.trimRight()——————unstandard</h1><p>作用：从一个字符串的右端移除空白字符<br>语法：str.trimRight()<br>参数：无<br>返回值：去掉右端空白字符的新字符串<br>是否改变原字符串：false<br>兼容性：chrome, firefox<br>版本：无相关规范<br>描述：</p>
<pre><code>var str = &quot;   foo  &quot;;
alert(str.length); // 8
str = str.trimRight();
alert(str.length); // 6
alert( str ); //&quot;   foo&quot;
</code></pre><h1 id="35-String-prototype-valueOf"><a href="#35-String-prototype-valueOf" class="headerlink" title="35. String.prototype.valueOf()"></a>35. String.prototype.valueOf()</h1><p>作用：返回一个String对象的原始值<br>语法：str.valueOf()<br>参数：无<br>返回值：String对象的原始值<br>是否改变原字符串：false<br>兼容性：all<br>版本：ES1<br>描述：String 对象的 valueOf 方法返回一个String对象的原始值。该值等同于String.prototype.toString()。<br>该方法通常在 JavaScript 内部被调用，而不是在代码里显示调用。</p>
<pre><code>x = new String(&quot;Hello world&quot;);
alert(x.valueOf())          // Displays &quot;Hello world&quot;
</code></pre><h1 id="36-String-raw"><a href="#36-String-raw" class="headerlink" title="36. String.raw()"></a>36. String.raw()</h1><p>作用：一个模板字符串的标签函数,用来获取一个模板字符串的原始字面量值的<br>语法：String.raw(callSite, …substitutions)<br>参数：</p>
<ul>
<li>callSite: 一个模板字符串的“调用点对象”</li>
<li>substitutions: 任意个可选的参数，表示任意个内插表达式对应的值</li>
</ul>
<p>返回值：<br>是否改变原字符串：<br>兼容性：chrome, firefox<br>版本：ES6<br>描述：String.raw() 是唯一一个内置的模板字符串标签函数，因为它太常用了。不过它并没有什么特殊能力，你自己也可以实现一个和它功能一模一样的标签函数。</p>
<pre><code>//String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。
String.raw`Hi\n${2+3}!`;
// &quot;Hi\\n5!&quot;
String.raw`Hi\u000A!`;
// &apos;Hi\u000A!&apos;

如果原字符串的斜杠已经转义，那么String.raw不会做任何处理。
String.raw`Hi\\n`
// &quot;Hi\\n&quot;

String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。
String.raw({ raw: &apos;test&apos; }, 0, 1, 2);
// &apos;t0e1s2t&apos;
// 等同于
String.raw({ raw: [&apos;t&apos;,&apos;e&apos;,&apos;s&apos;,&apos;t&apos;] }, 0, 1, 2);
</code></pre><h1 id="已被废除的特性"><a href="#已被废除的特性" class="headerlink" title="已被废除的特性"></a>已被废除的特性</h1><ul>
<li>String.prototype.big()</li>
<li>String.prototype.blink()</li>
<li>String.prototype.bold()</li>
<li>String.prototype.fixed()</li>
<li>String.prototype.fontcolor()</li>
<li>String.prototype.fontsize()</li>
<li>String.prototype.italics()</li>
<li>String.prototype.small()</li>
<li>String.prototype.strike()</li>
<li>String.prototype.sub()</li>
<li>String.prototype.sup()</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/26/Object对象内置方法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godzhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/26/Object对象内置方法总结/" itemprop="url">Object对象内置方法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-26T20:36:04+08:00">
                2017-06-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Object-assign"><a href="#1-Object-assign" class="headerlink" title="1. Object.assign()"></a>1. Object.assign()</h1><p>作用：用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象<br>语法：Object.assign(target, …sources)<br>参数：</p>
<ul>
<li>target: 目标对象</li>
<li>sources（多个）源对象</li>
</ul>
<p>返回值：目标对象<br>是否改变原对象：若target是已存在对象，则改变，只改变target<br>兼容性：IE-<br>版本：ES6<br>描述：如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。<br>Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象身上。该方法使用源对象的 [ [ Get ] ] 和目标对象的 [ [ Set ] ]，所以它会调用相关 getter 和 setter。因此，它分配属性而不是复制或定义新的属性。<br>注意， Object.assign 会跳过那些值为 null 或 undefined 的源对象。</p>
<pre><code>//复制一个object
var obj = { a: 1 };
var copy = Object.assign({}, obj);
console.log(copy); // { a: 1 }

//深度拷贝问题
//针对深度拷贝，需要使用其他方法，因为 Object.assign() 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。
function test() {
  let a = { b: {c:4} , d: { e: {f:1}} }
  let g = Object.assign({},a)
  let h = JSON.parse(JSON.stringify(a));
  console.log(g.d) // { e: { f: 1 } }
  g.d.e = 32
  console.log(&apos;g.d.e set to 32.&apos;) // g.d.e set to 32.
  console.log(g) // { b: { c: 4 }, d: { e: 32 } }
  console.log(a) // { b: { c: 4 }, d: { e: 32 } }
  console.log(h) // { b: { c: 4 }, d: { e: { f: 1 } } }
  h.d.e = 54
  console.log(&apos;h.d.e set to 54.&apos;) // h.d.e set to 54.
  console.log(g) // { b: { c: 4 }, d: { e: 32 } }
  console.log(a) // { b: { c: 4 }, d: { e: 32 } }
  console.log(h) // { b: { c: 4 }, d: { e: 54 } }
}
test();

//合并objects
var o1 = { a: 1 };
var o2 = { b: 2 };
var o3 = { c: 3 };
var obj = Object.assign(o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }
console.log(o1);  // { a: 1, b: 2, c: 3 }, 注意目标对象自身也会改变。

//拷贝 symbol 类型的属性
var o1 = { a: 1 };
var o2 = { [Symbol(&quot;foo&quot;)]: 2 };
var obj = Object.assign({}, o1, o2);
console.log(obj); // { a: 1, [Symbol(&quot;foo&quot;)]: 2 }

//继承属性和不可枚举属性是不能拷贝的
var obj = Object.create({foo: 1}, { // foo 是个继承属性。
    bar: {
        value: 2  // bar 是个不可枚举属性。
    },
    baz: {
        value: 3,
        enumerable: true  // baz 是个自身可枚举属性。
    }
});
var copy = Object.assign({}, obj);
console.log(copy); // { baz: 3 }

//原始类型会被包装为 object
var v1 = &quot;abc&quot;;
var v2 = true;
var v3 = 10;
var v4 = Symbol(&quot;foo&quot;)
var obj = Object.assign({}, v1, null, v2, undefined, v3, v4); 
// 原始类型会被包装，null 和 undefined 会被忽略。
// 注意，只有字符串的包装对象才可能有自身可枚举属性。
console.log(obj); // { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }

//异常会打断接下来的拷贝任务
var target = Object.defineProperty({}, &quot;foo&quot;, {
    value: 1,
    writable: false
}); // target 的 foo 属性是个只读属性。

Object.assign(target, {bar: 2}, {foo2: 3, foo: 3, foo3: 3}, {baz: 4});
// TypeError: &quot;foo&quot; is read-only
// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。

console.log(target.bar);  // 2，说明第一个源对象拷贝成功了。
console.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。
console.log(target.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。
console.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。
console.log(target.baz);  // undefined，第三个源对象更是不会被拷贝到的。
</code></pre><h1 id="2-Object-create"><a href="#2-Object-create" class="headerlink" title="2. Object.create()"></a>2. Object.create()</h1><p>作用：使用指定的原型对象和其属性创建了一个新的对象<br>语法：Object.create(proto, propertiesObject)<br>参数：</p>
<ul>
<li>proto: 一个对象，应该是新创建的对象的原型</li>
<li>propertiesObject: 可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符（这些属性描述符的结构与Object.defineProperties()的第二个参数一样）。注意：该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的。</li>
</ul>
<p>返回值：具有指定原型对象属性的新的对象<br>是否改变原对象：false<br>兼容性：IE9+<br>版本：ES5<br>描述：如果 proto 参数不是 null 或一个对象值，则抛出一个 TypeError 异常。</p>
<pre><code>function Shape() {
  this.x = 0;
  this.y = 0;
}

Shape.prototype.move = function(x, y) {
    this.x += x;
    this.y += y;
    console.info(&quot;Shape moved.&quot;);
};

function Rectangle() {
  Shape.call(this); //call super constructor.
}
Rectangle.prototype = Object.create(Shape.prototype);

var rect = new Rectangle();

rect instanceof Rectangle; //true
rect instanceof Shape; //true

function Fn(){
    this.name = &apos;zhangqi&apos;;
}

Fn.prototype = {
    init: function(){
        console.log(1);
    }
}

var a = Object.create(Fn.prototype,{foo:{writable:true, configurable:true, value: &quot;hello&quot;}});

console.log(a.foo); //hello
</code></pre><h1 id="3-Object-defineProperties"><a href="#3-Object-defineProperties" class="headerlink" title="3. Object.defineProperties()"></a>3. Object.defineProperties()</h1><p>作用：直接在一个对象上定义新的属性或修改现有属性<br>语法：Object.defineProperties(obj, props)<br>参数：</p>
<ul>
<li>obj: 将要被添加或修改属性的对象</li>
<li>props: 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置</li>
</ul>
<p>返回值：被传递给函数的对象<br>是否改变原对象：true<br>兼容性：IE9+<br>版本：ES5<br>描述：—</p>
<pre><code>var obj = {};
Object.defineProperties(obj, {
  &quot;property1&quot;: {
    value: true,
    writable: true
  },
  &quot;property2&quot;: {
    value: &quot;Hello&quot;,
    writable: false
  }
  // 等等.
});
alert(obj.property2) //弹出&quot;Hello&quot;
</code></pre><h1 id="4-Object-defineProperty"><a href="#4-Object-defineProperty" class="headerlink" title="4. Object.defineProperty()"></a>4. Object.defineProperty()</h1><p>作用：直接在一个对象上定义一个新属性，或者修改一个对象的现有属性<br>语法：Object.defineProperty(obj, prop, descriptor)<br>参数：</p>
<ul>
<li>obj: 要在其上定义属性的对象</li>
<li>prop: 要定义或修改的属性名称</li>
<li>descriptor: 将被定义或修改的属性的描述符</li>
</ul>
<p>返回值：被传递给函数的对象<br>是否改变原对象：true<br>兼容性：IE9+<br>版本：ES5<br>描述：<br>数据描述符和存取描述符均具有以下可选键值：</p>
<h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，也能够被删除。默认为 false。</p>
<h3 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h3><p>当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。<br>数据描述符同时具有以下可选键值：</p>
<h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</p>
<h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p>当且仅当该属性的 writable 为 true 时，该属性才能被赋值运算符改变。默认为 false。<br>存取描述符同时具有以下可选键值：</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。</p>
<pre><code>var o = {}; // 创建一个新对象
property descriptor
Object.defineProperty(o, &quot;a&quot;, {
  value : 37,
  writable : true,
  enumerable : true,
  configurable : true
});
// 对象o拥有了属性a，值为37
var bValue;
Object.defineProperty(o, &quot;b&quot;, {
  get : function(){
    return bValue;
  },
  set : function(newValue){
    bValue = newValue;
  },
  enumerable : true,
  configurable : true
});
o.b = 38;
// 对象o拥有了属性b，值为38

// 数据描述符和存取描述符不能混合使用
Object.defineProperty(o, &quot;conflict&quot;, {
  value: 0x9f91102, 
  get: function() { 
    return 0xdeadbeef; 
  } 
});
// throws a TypeError: value appears only in data descriptors, get appears only in accessor descriptors

//Writable 属性
var o = {}; // 创建一个新对象
Object.defineProperty(o, &quot;a&quot;, { value : 37, writable : false });
console.log(o.a); // 打印 37
o.a = 25; // 没有错误抛出（在严格模式下会抛出，即使之前已经有相同的值）
console.log(o.a); // 打印 37， 赋值不起作用。

//Enumerable 特性
var o = {};
Object.defineProperty(o, &quot;a&quot;, { value : 1, enumerable:true });
Object.defineProperty(o, &quot;b&quot;, { value : 2, enumerable:false });
Object.defineProperty(o, &quot;c&quot;, { value : 3 }); // enumerable defaults to false
o.d = 4; // 如果使用直接赋值的方式创建对象的属性，则这个属性的enumerable为true
for (var i in o) {    
  console.log(i);  
}
// 打印 &apos;a&apos; 和 &apos;d&apos; (in undefined order)
Object.keys(o); // [&quot;a&quot;, &quot;d&quot;]
o.propertyIsEnumerable(&apos;a&apos;); // true
o.propertyIsEnumerable(&apos;b&apos;); // false
o.propertyIsEnumerable(&apos;c&apos;); // false

//Configurable 特性
//configurable 特性表示对象的属性是否可以被删除，以及除 writable 特性外的其他特性是否可以被修改。
var o = {};
Object.defineProperty(o, &quot;a&quot;, { get : function(){return 1;}, configurable : false } );
// throws a TypeError一旦把属性定义为不可配置的，就不能再变回可配置了
Object.defineProperty(o, &quot;a&quot;, {configurable : true}); 
// throws a TypeError
Object.defineProperty(o, &quot;a&quot;, {enumerable : true}); 
// throws a TypeError (set was undefined previously) 
Object.defineProperty(o, &quot;a&quot;, {set : function(){}}); 
// throws a TypeError (even though the new get does exactly the same thing) 
Object.defineProperty(o, &quot;a&quot;, {get : function(){return 1;}});
// throws a TypeError
Object.defineProperty(o, &quot;a&quot;, {value : 12});
console.log(o.a); // 1
delete o.a; // Nothing happens
console.log(o.a); // 1

//一般的 Setters 和 Getters
function Archiver() {
  var temperature = null;
  var archive = [];

  Object.defineProperty(this, &apos;temperature&apos;, {
    get: function() {
      console.log(&apos;get!&apos;);
      return temperature;
    },
    set: function(value) {
      temperature = value;
      archive.push({ val: temperature });
    }
  });

  this.getArchive = function() { return archive; };
}

var arc = new Archiver();
arc.temperature; // &apos;get!&apos;
arc.temperature = 11;
arc.temperature = 13;
arc.getArchive(); // [{ val: 11 }, { val: 13 }]
</code></pre><h1 id="5-Object-entries"><a href="#5-Object-entries" class="headerlink" title="5. Object.entries()"></a>5. Object.entries()</h1><p>作用：返回一个给定对象自己的可枚举属性[key，value]对的数组，数组中键值对的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致（区别在于一个for-in循环也枚举原型链中的属性）<br>语法：Object.entries(obj)<br>参数：obj: 返回该对象由可枚举属性名和对应属性值组成的的键值对<br>返回值：一个给定对象自己的枚举属性[key，value]对的数组<br>是否改变原对象：<br>兼容性：—<br>版本：ES7<br>描述：</p>
<pre><code>var obj = { foo: &quot;bar&quot;, baz: 42 };
console.log(Object.entries(obj)); 
// [ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42] ]

// 类数组对象
var obj = { 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; };
console.log(Object.entries(obj)); 
// [ [&apos;0&apos;, &apos;a&apos;], [&apos;1&apos;, &apos;b&apos;], [&apos;2&apos;, &apos;c&apos;] ]

// 带有随机（非顺序）排列属性名的类数组对象
var an_obj = { 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; };
console.log(Object.entries(an_obj)); 
// [ [&apos;2&apos;, &apos;b&apos;], [&apos;7&apos;, &apos;c&apos;], [&apos;100&apos;, &apos;a&apos;] ]

// getFoo是不可枚举属性
var my_obj = Object.create(
   {}, 
   { getFoo: { value: function() { return this.foo; } } }
);
my_obj.foo = &quot;bar&quot;;
console.log(Object.entries(my_obj)); 
// [ [&apos;foo&apos;, &apos;bar&apos;] ]

// 非对象参数会被强行视为对象
console.log(Object.entries(&quot;foo&quot;)); 
// [ [&apos;0&apos;, &apos;f&apos;], [&apos;1&apos;, &apos;o&apos;], [&apos;2&apos;, &apos;o&apos;] ]
</code></pre><h1 id="6-Object-freeze"><a href="#6-Object-freeze" class="headerlink" title="6. Object.freeze()"></a>6. Object.freeze()</h1><p>作用：冻结一个对象，这个对象永远是不可变的。<br>语法：Object.freeze(obj)<br>参数：obj: 被冻结的对象<br>返回值：被冻结的对象<br>是否改变原对象：true<br>兼容性：IE9+<br>版本：ES5<br>描述：如果一个属性的值是个对象，则这个对象中的属性是可以修改的，除非它也是个冻结对象。</p>
<pre><code>var obj = {name: &apos;zhangqi&apos;,age: 29};
var newObj = Object.freeze(obj);

obj.name = &apos;zhaojinge&apos;;
console.log(obj);     //{name: &apos;zhangqi&apos;,age: 29}
delete obj.age;
console.log(obj);     //{name: &apos;zhangqi&apos;,age: 29}
newObj.name = &apos;xiaogai&apos;;
console.log(newObj);  //{name: &apos;zhangqi&apos;,age: 29}

//一个冻结对象中的非冻结对象是可以被修改的（浅冻结）
var obj = {fn: {name: &apos;zhangqi&apos;}};
Object.freeze(obj);
obj.fn.name = &apos;zhaojinge&apos;;
console.log(obj.fn.name);  //zhaojinge
</code></pre><h1 id="7-Object-getOwnPropertyDescriptor"><a href="#7-Object-getOwnPropertyDescriptor" class="headerlink" title="7. Object.getOwnPropertyDescriptor()"></a>7. Object.getOwnPropertyDescriptor()</h1><p>作用：返回指定对象上一个自有属性对应的属性描述符<br>语法：Object.getOwnPropertyDescriptor(obj, prop)<br>参数：</p>
<ul>
<li>obj: 在该对象上查看属性</li>
<li>prop: 一个属性名称，该属性的属性描述符将被返回</li>
</ul>
<p>返回值：如果指定的属性存在于对象上，则返回其属性描述符（property descriptor），否则返回 undefined。<br>是否改变原对象：false<br>兼容性：IE8+<br>版本：ES5<br>描述：<br>一个属性描述符是一个记录，由下面属性当中的某些组成的：<br>value<br>该属性的值(仅针对数据属性描述符有效)<br>writable<br>当且仅当属性的值可以被改变时为true。(仅针对数据属性描述有效)<br>get<br>获取该属性的访问器函数（getter）。如果没有访问器， 该值为undefined。(仅针对包含访问器或设置器的属性描述有效)<br>set<br>获取该属性的设置器函数（setter）。 如果没有设置器， 该值为undefined。(仅针对包含访问器或设置器的属性描述有效)<br>configurable<br>当且仅当指定对象的属性描述可以被改变或者属性可被删除时，为true。<br>enumerable<br>当且仅当指定对象的属性可以被枚举出时，为 true。</p>
<pre><code>var o, d;

o = { get foo() { return 17; } };
d = Object.getOwnPropertyDescriptor(o, &quot;foo&quot;);
// d is { configurable: true, enumerable: true, get: /*访问器函数*/, set: undefined }

o = { bar: 42 };
d = Object.getOwnPropertyDescriptor(o, &quot;bar&quot;);
// d is { configurable: true, enumerable: true, value: 42, writable: true }

o = {};
Object.defineProperty(o, &quot;baz&quot;, { value: 8675309, writable: false, enumerable: false });
d = Object.getOwnPropertyDescriptor(o, &quot;baz&quot;);
// d is { value: 8675309, writable: false, enumerable: false, configurable: false }
</code></pre><h1 id="8-Object-getOwnPropertyDescriptors"><a href="#8-Object-getOwnPropertyDescriptors" class="headerlink" title="8. Object.getOwnPropertyDescriptors()"></a>8. Object.getOwnPropertyDescriptors()</h1><p>作用：用来获取一个对象的所有自身属性的描述符<br>语法：Object.getOwnPropertyDescriptors(obj);<br>参数：obj: 任意对象<br>返回值：所指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象<br>是否改变原对象：false<br>兼容性：只有火狐支持<br>版本：ES8<br>描述：—</p>
<p>浅拷贝一个对象<br>Object.assign() 方法只能拷贝源对象的可枚举的自身属性，同时拷贝时无法拷贝属性的特性们，而且访问器属性会被转换成数据属性，也无法拷贝源对象的原型，该方法配合 Object.create() 方法可以实现上面说的这些。</p>
<pre><code>Object.create(
  Object.getPrototypeOf(obj), 
  Object.getOwnPropertyDescriptors(obj) 
);
</code></pre><p>创建子类</p>
<p>创建子类的典型方法是定义子类，将其原型设置为超类的实例，然后在该实例上定义属性。这可能会让尴尬，特别是对于 getters 和 setter 而言。 相反，您可以使用此代码设置原型：</p>
<pre><code>function superclass() {}
superclass.prototype = {
  // 在这里定义方法和属性
};
function subclass() {}
subclass.prototype = Object.create(superclass.prototype, Object.getOwnPropertyDescriptors({
  // 在这里定义方法和属性
}));
</code></pre><h1 id="9-Object-getOwnPropertyNames"><a href="#9-Object-getOwnPropertyNames" class="headerlink" title="9. Object.getOwnPropertyNames()"></a>9. Object.getOwnPropertyNames()</h1><p>作用：返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组<br>语法：Object.getOwnPropertyNames(obj)<br>参数：obj: 一个对象，其自身的可枚举和不可枚举属性的名称被返回<br>返回值：数组<br>是否改变原对象：false<br>兼容性：IE9+<br>版本：ES5<br>描述：数组中枚举属性的顺序与通过 for…in 循环（或 Object.keys）迭代该对象属性时一致。 数组中不可枚举属性的顺序未定义</p>
<pre><code>var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
console.log(Object.getOwnPropertyNames(arr).sort()); // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;length&quot;]

// 类数组对象
var obj = { 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;};
console.log(Object.getOwnPropertyNames(obj).sort()); // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]

// 使用Array.forEach输出属性名和属性值
Object.getOwnPropertyNames(obj).forEach(function(val, idx, array) {
  console.log(val + &quot; -&gt; &quot; + obj[val]);
});
// 输出
// 0 -&gt; a
// 1 -&gt; b
// 2 -&gt; c

//不可枚举属性
var my_obj = Object.create({}, {
  getFoo: {
    value: function() { return this.foo; },
    enumerable: false
  }
});
my_obj.foo = 1;

console.log(Object.getOwnPropertyNames(my_obj).sort()); // [&quot;foo&quot;, &quot;getFoo&quot;]

//该方法不会获取到原型链上的属性
function ParentClass() {}
ParentClass.prototype.inheritedMethod = function() {};

function ChildClass() {
  this.prop = 5;
  this.method = function() {};
}

ChildClass.prototype = new ParentClass;
ChildClass.prototype.prototypeMethod = function() {};

console.log(
  Object.getOwnPropertyNames(
    new ChildClass()  // [&quot;prop&quot;, &quot;method&quot;]
  )
);
</code></pre><h1 id="10-Object-getOwnPropertySymbols"><a href="#10-Object-getOwnPropertySymbols" class="headerlink" title="10. Object.getOwnPropertySymbols()"></a>10. Object.getOwnPropertySymbols()</h1><p>作用：返回一个数组，该数组包含了指定对象自身的（非继承的）所有 symbol 属性键<br>语法：Object.getOwnPropertySymbols(obj)<br>参数：obj<br>返回值：数组<br>是否改变原对象：false<br>兼容性：IE-<br>版本：ES6<br>描述：</p>
<pre><code>var obj = {};
var a = Symbol(&quot;a&quot;);
var b = Symbol.for(&quot;b&quot;);

obj[a] = &quot;localSymbol&quot;;
obj[b] = &quot;globalSymbol&quot;;

var objectSymbols = Object.getOwnPropertySymbols(obj);

console.log(objectSymbols.length); // 2
console.log(objectSymbols)         // [Symbol(a), Symbol(b)]
console.log(objectSymbols[0])      // Symbol(a)
</code></pre><h1 id="11-Object-getPrototypeOf"><a href="#11-Object-getPrototypeOf" class="headerlink" title="11. Object.getPrototypeOf()"></a>11. Object.getPrototypeOf()</h1><p>作用：返回指定对象的原型（即, 内部[[Prototype]]属性的值）<br>语法：Object.getPrototypeOf(obj)<br>参数：obj: 要返回其原型的对象<br>返回值：给定对象的原型。如果没有继承属性，则返回 null<br>是否改变原对象：false<br>兼容性：IE9+<br>版本：ES5<br>描述：</p>
<pre><code>let proto = {};
let obj = Object.create(proto);

Object.getPrototypeOf(obj) === proto;
 // true
</code></pre><p>在 ES5 中，如果参数不是一个对象类型，将抛出一个  TypeError 异常。在 ES6 /ES2015中，参数被强制转换为一个 Object。</p>
<pre><code>&gt; Object.getPrototypeOf(&quot;foo&quot;);
TypeError: &quot;foo&quot; is not an object  
// ES5 code

&gt; Object.getPrototypeOf(&quot;foo&quot;);
String.prototype                   
// ES6 code
</code></pre><h1 id="12-Object-is"><a href="#12-Object-is" class="headerlink" title="12. Object.is()"></a>12. Object.is()</h1><p>作用：确定两个值是否是 相同的值<br>语法：Object.is(value1, value2);<br>参数：value1, value2: 需要比较的值<br>返回值：true || false<br>是否改变原对象：false<br>兼容性：IE- Safari-<br>版本：ES6<br>描述：<br>Object.is() 会在下面这些情况下认为两个值是相同的：</p>
<p>两个值都是 undefined<br>两个值都是 null<br>两个值都是 true 或者都是 false<br>两个值是由相同个数的字符按照相同的顺序组成的字符串<br>两个值指向同一个对象<br>两个值都是数字并且<br>都是正零 +0<br>都是负零 -0<br>都是 NaN<br>都是除零和 NaN 外的其它同一个数字</p>
<pre><code>Object.is(&apos;foo&apos;, &apos;foo&apos;);     // true
Object.is(window, window);   // true

Object.is(&apos;foo&apos;, &apos;bar&apos;);     // false
Object.is([], []);           // false

var test = { a: 1 };
Object.is(test, test);       // true

Object.is(null, null);       // true

// 特例
Object.is(0, -0);            // false
Object.is(-0, -0);           // true
Object.is(NaN, 0/0);         // true
</code></pre><h1 id="13-Object-isExtensible"><a href="#13-Object-isExtensible" class="headerlink" title="13. Object.isExtensible()"></a>13. Object.isExtensible()</h1><p>作用：判断一个对象是否是可扩展的<br>语法：Object.isExtensible(obj)<br>参数：obj: 要检测的对象<br>返回值：true || false<br>是否改变原对象：false<br>兼容性：IE9+<br>版本：ES5<br>描述：</p>
<pre><code>// 新对象默认是可扩展的.
var empty = {};
Object.isExtensible(empty); // === true

// ...可以变的不可扩展.
Object.preventExtensions(empty);
Object.isExtensible(empty); // === false

// 密封对象是不可扩展的.
var sealed = Object.seal({});
Object.isExtensible(sealed); // === false

// 冻结对象也是不可扩展.
var frozen = Object.freeze({});
Object.isExtensible(frozen); // === false

//在 ES5 中，如果参数不是一个对象类型，将抛出一个 TypeError 异常。在 ES6 中， non-object 参数将被视为一个不可扩展的普通对象，因此会返回 false 。
Object.isExtensible(1);
// TypeError: 1 is not an object (ES5 code)
Object.isExtensible(1);
// false                         (ES6 code)
</code></pre><h1 id="14-Object-isFrozen"><a href="#14-Object-isFrozen" class="headerlink" title="14. Object.isFrozen()"></a>14. Object.isFrozen()</h1><p>作用：判断一个对象是否被冻结 frozen<br>语法：Object.isFrozen(obj)<br>参数：obj: 被检测的对象<br>返回值：true || false<br>是否改变原对象：false<br>兼容性：IE9+, opera-<br>版本：ES5<br>描述：</p>
<pre><code>// 一个对象默认是可扩展的,所以它也是非冻结的.
assert(Object.isFrozen({}) === false);

// 一个不可扩展的空对象同时也是一个冻结对象.
var vacuouslyFrozen = Object.preventExtensions({});
assert(Object.isFrozen(vacuouslyFrozen) === true);

// 一个非空对象默认也是非冻结的.
var oneProp = { p: 42 };
assert(Object.isFrozen(oneProp) === false);

// 让这个对象变的不可扩展,并不意味着这个对象变成了冻结对象,
// 因为p属性仍然是可以配置的(而且可写的).
Object.preventExtensions(oneProp);
assert(Object.isFrozen(oneProp) === false);
// ...如果删除了这个属性,则它会成为一个冻结对象.
delete oneProp.p;
assert(Object.isFrozen(oneProp) === true);

// 一个不可扩展的对象,拥有一个不可写但可配置的属性,则它仍然是非冻结的.
var nonWritable = { e: &quot;plep&quot; };
Object.preventExtensions(nonWritable);
Object.defineProperty(nonWritable, &quot;e&quot;, { writable: false }); // 变得不可写
assert(Object.isFrozen(nonWritable) === false);

// 把这个属性改为不可配置,会让这个对象成为冻结对象.
Object.defineProperty(nonWritable, &quot;e&quot;, { configurable: false }); // 变得不可配置
assert(Object.isFrozen(nonWritable) === true);

// 一个不可扩展的对象,拥有一个不可配置但可写的属性,则它仍然是非冻结的.
var nonConfigurable = { release: &quot;the kraken!&quot; };
Object.preventExtensions(nonConfigurable);
Object.defineProperty(nonConfigurable, &quot;release&quot;, { configurable: false });
assert(Object.isFrozen(nonConfigurable) === false);

// 把这个属性改为不可写,会让这个对象成为冻结对象.
Object.defineProperty(nonConfigurable, &quot;release&quot;, { writable: false });
assert(Object.isFrozen(nonConfigurable) === true);

// 一个不可扩展的对象,值拥有一个访问器属性,则它仍然是非冻结的.
var accessor = { get food() { return &quot;yum&quot;; } };
Object.preventExtensions(accessor);
assert(Object.isFrozen(accessor) === false);

// ...但把这个属性改为不可配置,会让这个对象成为冻结对象.
Object.defineProperty(accessor, &quot;food&quot;, { configurable: false });
assert(Object.isFrozen(accessor) === true);

// 使用Object.freeze是冻结一个对象最方便的方法.
var frozen = { 1: 81 };
assert(Object.isFrozen(frozen) === false);
Object.freeze(frozen);
assert(Object.isFrozen(frozen) === true);

// 一个冻结对象也是一个密封对象.
assert(Object.isSealed(frozen) === true);

// 当然,更是一个不可扩展的对象.
assert(Object.isExtensible(frozen) === false);
</code></pre><h1 id="15-Object-isSealed"><a href="#15-Object-isSealed" class="headerlink" title="15. Object.isSealed()"></a>15. Object.isSealed()</h1><p>作用：判断一个对象是否被密封(sealed)<br>语法：Object.isSealed(obj)<br>参数：obj<br>返回值：true || false<br>是否改变原对象：false<br>兼容性：IE9+, opera-<br>版本：ES5<br>描述：</p>
<pre><code>// 新建的对象默认不是密封的.
var empty = {};
Object.isSealed(empty); // === false

// 如果你把一个空对象变的不可扩展,则它同时也会变成个密封对象.
Object.preventExtensions(empty);
Object.isSealed(empty); // === true

// 但如果这个对象不是空对象,则它不会变成密封对象,因为密封对象的所有自身属性必须是不可配置的.
var hasProp = { fee: &quot;fie foe fum&quot; };
Object.preventExtensions(hasProp);
Object.isSealed(hasProp); // === false

// 如果把这个属性变的不可配置,则这个对象也就成了密封对象.
Object.defineProperty(hasProp, &quot;fee&quot;, { configurable: false });
Object.isSealed(hasProp); // === true

// 最简单的方法来生成一个密封对象,当然是使用Object.seal.
var sealed = {};
Object.seal(sealed);
Object.isSealed(sealed); // === true

// 一个密封对象同时也是不可扩展的.
Object.isExtensible(sealed); // === false

// 一个密封对象也可以是一个冻结对象,但不是必须的.
Object.isFrozen(sealed); // === true ，所有的属性都是不可写的
var s2 = Object.seal({ p: 3 });
Object.isFrozen(s2); // === false， 属性&quot;p&quot;可写

var s3 = Object.seal({ get p() { return 0; } });
Object.isFrozen(s3); // === true ，访问器属性不考虑可写不可写,只考虑是否可配置

//在 ES5 中，如果参数不是一个对象类型（原始类型），将抛出一个 TypeError  异常。在 ES6 中， non-object 参数将被视为一个密封的普通对象，因此会返回 true。
Object.isSealed(1);
// TypeError: 1 is not an object (ES5 code)
Object.isSealed(1);
// true                          (ES6 code)
</code></pre><h1 id="16-Object-keys"><a href="#16-Object-keys" class="headerlink" title="16. Object.keys()"></a>16. Object.keys()</h1><p>作用：返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致<br>语法：Object.keys(obj)<br>参数：obj<br>返回值：一个表示给定对象的所有可枚举属性的字符串数组<br>是否改变原对象：false<br>兼容性：IE9+<br>版本：ES5<br>描述：Object.keys 返回一个所有元素为字符串的数组，其元素来自于从给定的对象上面<em>可直接枚举的属性</em></p>
<pre><code>var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
alert(Object.keys(arr)); // &quot;0,1,2&quot;

/* 类数组对象 */ 
var obj = { 0 : &quot;a&quot;, 1 : &quot;b&quot;, 2 : &quot;c&quot;};
alert(Object.keys(obj)); // &quot;0,1,2&quot;

/* 具有随机键排序的数组类对象 */
var an_obj = { 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; };
console.log(Object.keys(an_obj)); 
// console: [&apos;2&apos;, &apos;7&apos;, &apos;100&apos;]
</code></pre><p>在ES5，如果此方法的参数不是一个对象（原始的），那么它会造成 TypeError。在ES2015，非对象的参数将被强制转换为一个对象。<br>    Object.keys(“foo”);<br>    // TypeError: “foo” is not an object (ES5 code)</p>
<pre><code>Object.keys(&quot;foo&quot;);
// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]                   (ES2015 code)
</code></pre><h1 id="17-Object-preventExtensions"><a href="#17-Object-preventExtensions" class="headerlink" title="17. Object.preventExtensions()"></a>17. Object.preventExtensions()</h1><p>作用：让一个对象变的不可扩展，也就是永远不能再添加新的属性<br>语法：Object.preventExtensions(obj)<br>参数：obj: 将要变得不可扩展的对象<br>返回值：obj<br>是否改变原对象：true<br>兼容性：IE9+, opera-<br>版本：ES5<br>描述：</p>
<pre><code>var obj = {name: &apos;zhangqi&apos;};
var a = Object.preventExtensions(obj);
obj.age = 29;
console.log(obj); //Object {name: &quot;zhangqi&quot;}
console.log(a);   //Object {name: &quot;zhangqi&quot;}
console.log(a === obj);  //true

// 字面量方式定义的对象默认是可扩展的.
var empty = {};
assert(Object.isExtensible(empty) === true);

// ...但可以改变.
Object.preventExtensions(empty);
assert(Object.isExtensible(empty) === false);

// 使用Object.defineProperty方法为一个不可扩展的对象添加新属性会抛出异常.
var nonExtensible = { removable: true };
Object.preventExtensions(nonExtensible);
Object.defineProperty(nonExtensible, &quot;new&quot;, { value: 8675309 }); // 抛出TypeError异常

// 在严格模式中,为一个不可扩展对象的新属性赋值会抛出TypeError异常.
function fail()
{
  &quot;use strict&quot;;
  nonExtensible.newProperty = &quot;FAIL&quot;; // throws a TypeError
}
fail();

// 一个不可扩展对象的原型是不可更改的,__proto__是个非标准魔法属性,可以更改一个对象的原型.
var fixed = Object.preventExtensions({});
fixed.__proto__ = { oh: &quot;hai&quot; }; // 抛出TypeError异常
</code></pre><h1 id="18-Object-prototype-defineGetter-————已被废除"><a href="#18-Object-prototype-defineGetter-————已被废除" class="headerlink" title="18. Object.prototype.defineGetter()————已被废除"></a>18. Object.prototype.<strong>defineGetter</strong>()————已被废除</h1><h1 id="19-Object-prototype-defineSetter-————已被废除"><a href="#19-Object-prototype-defineSetter-————已被废除" class="headerlink" title="19. Object.prototype.defineSetter()————已被废除"></a>19. Object.prototype.<strong>defineSetter</strong>()————已被废除</h1><h1 id="20-Object-prototype-lookupGetter-————已被废除"><a href="#20-Object-prototype-lookupGetter-————已被废除" class="headerlink" title="20. Object.prototype.lookupGetter()————已被废除"></a>20. Object.prototype.<strong>lookupGetter</strong>()————已被废除</h1><h1 id="21-Object-prototype-lookupSetter-————已被废除"><a href="#21-Object-prototype-lookupSetter-————已被废除" class="headerlink" title="21. Object.prototype.lookupSetter()————已被废除"></a>21. Object.prototype.<strong>lookupSetter</strong>()————已被废除</h1><h1 id="22-Object-prototype-hasOwnProperty"><a href="#22-Object-prototype-hasOwnProperty" class="headerlink" title="22. Object.prototype.hasOwnProperty()"></a>22. Object.prototype.hasOwnProperty()</h1><p>作用：指示对象是否具有指定的属性作为自身（不继承）属性<br>语法：obj.hasOwnProperty(obj)<br>参数：obj: 要检测的属性字符串名称或者symbol<br>返回值：true || false<br>是否改变原对象：false<br>兼容性：all<br>版本：ES3<br>描述：所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性</p>
<pre><code>o = new Object();
o.prop = &apos;exists&apos;;

function changeO() {
  o.newprop = o.prop;
  delete o.prop;
}

o.hasOwnProperty(&apos;prop&apos;);   // 返回 true
changeO();
o.hasOwnProperty(&apos;prop&apos;);   // 返回 false

o = new Object();
o.prop = &apos;exists&apos;;
o.hasOwnProperty(&apos;prop&apos;);             // 返回 true
o.hasOwnProperty(&apos;toString&apos;);         // 返回 false
o.hasOwnProperty(&apos;hasOwnProperty&apos;);   // 返回 false
</code></pre><p>使用 hasOwnProperty 作为属性名</p>
<p>JavaScript 并没有保护 hasOwnProperty 属性名，因此某个对象是有可能存在使用这个属性名的属性，使用外部的 hasOwnProperty 获得正确的结果是需要的：</p>
<pre><code>var foo = {
    hasOwnProperty: function() {
        return false;
    },
    bar: &apos;Here be dragons&apos;
};

foo.hasOwnProperty(&apos;bar&apos;); // 始终返回 false

// 如果担心这种情况，可以直接使用原型链上真正的 hasOwnProperty 方法
({}).hasOwnProperty.call(foo, &apos;bar&apos;); // true

// 也可以使用 Object 原型上的 hasOwnProperty 属性
Object.prototype.hasOwnProperty.call(foo, &apos;bar&apos;); // true
</code></pre><h1 id="23-Object-prototype-isPrototypeOf"><a href="#23-Object-prototype-isPrototypeOf" class="headerlink" title="23. Object.prototype.isPrototypeOf()"></a>23. Object.prototype.isPrototypeOf()</h1><p>作用：用于测试一个对象是否存在于另一个对象的原型链上<br>语法：prototypeObj.isPrototypeOf(object)<br>参数：object: 在该对象的原型链上搜寻<br>返回值：true || false<br>是否改变原对象：false<br>兼容性：all<br>版本：ES3<br>描述：</p>
<pre><code>function Fn(){}
Fn.prototype = {}
function newFn(){}
newFn.prototype = new Fn();
var fn = new newFn();
console.log(Fn.prototype.isPrototypeOf(fn));
</code></pre><h1 id="24-Object-prototype-propertyIsEnumerable"><a href="#24-Object-prototype-propertyIsEnumerable" class="headerlink" title="24. Object.prototype.propertyIsEnumerable()"></a>24. Object.prototype.propertyIsEnumerable()</h1><p>作用：返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性<br>语法：obj.propertyIsEnumerable(prop)<br>参数：prop: 需要测试的属性名<br>返回值：true || false<br>是否改变原对象：false<br>兼容性：all<br>版本：ES3<br>描述：</p>
<pre><code>var obj = {name: &apos;zhangqi&apos;}
var a = obj.propertyIsEnumerable(&apos;name&apos;);
console.log(a);  //true

//用户自定义对象(true)和引擎内置对象(false)
var a = [&apos;is enumerable&apos;];
a.propertyIsEnumerable(0);          // 返回 true
a.propertyIsEnumerable(&apos;length&apos;);   // 返回 false
Math.propertyIsEnumerable(&apos;random&apos;);   // 返回 false
this.propertyIsEnumerable(&apos;Math&apos;);     // 返回 false

继承属性不可枚举
function fn(){}
fn.prototype.name = &apos;zhangqi&apos;;

function newfn(){}
newfn.prototype = new fn();
var a = new newfn(); 
console.log(a.propertyIsEnumerable(&apos;name&apos;));
</code></pre><h1 id="25-Object-prototype-toLocalString"><a href="#25-Object-prototype-toLocalString" class="headerlink" title="25. Object.prototype.toLocalString()"></a>25. Object.prototype.toLocalString()</h1><p>作用：回一个该对象的字符串表示。该方法主要用于被本地化相关对象覆盖<br>语法：obj.toLocaleString()<br>参数：无<br>返回值：该对象的字符串表示<br>是否改变原对象：false<br>兼容性：all<br>版本：ES3<br>描述：Object’s toLocaleString 返回调用 toString() 方法的结果</p>
<pre><code>var obj = {
    fn: function(){
        return 1;
    }
}

var a = obj.toLocaleString();

console.log(a); //[object Object]
console.log(typeof a);//string
</code></pre><h1 id="26-Object-prototype-toSource-————unstandard"><a href="#26-Object-prototype-toSource-————unstandard" class="headerlink" title="26. Object.prototype.toSource()————unstandard"></a>26. Object.prototype.toSource()————unstandard</h1><p>作用：返回一个表示对象源代码的字符串<br>语法：obj.toSource()<br>参数：无<br>返回值：一个表示对象的源代码的字符串<br>是否改变原对象：false<br>兼容性：—<br>版本：—<br>描述：</p>
<p>重写toSource()方法<br>允许对象重写toSource()方法。例如：</p>
<pre><code>function Person(name) {
    this.name = name;
}
Person.prototype.toSource = function Person_toSource() {
    return &quot;new Person(&quot; + uneval(this.name) + &quot;)&quot;;
};
alert(new Person(&quot;Joe&quot;).toSource()); // ---&gt; new Person(&quot;Joe&quot;)
</code></pre><h1 id="27-Object-prototype-unwatch-————unstandard"><a href="#27-Object-prototype-unwatch-————unstandard" class="headerlink" title="27. Object.prototype.unwatch()————unstandard"></a>27. Object.prototype.unwatch()————unstandard</h1><p>作用：删除一个 watch() 设置的 watchpoint.<br>语法：obj.unwatch(prop)<br>参数：prop: 想要停止监视的对象的属性名<br>返回值：—<br>是否改变原对象：false<br>兼容性：firefox<br>版本：—<br>描述：见watch()方法</p>
<h1 id="28-Object-prototype-valueOf"><a href="#28-Object-prototype-valueOf" class="headerlink" title="28. Object.prototype.valueOf()"></a>28. Object.prototype.valueOf()</h1><p>作用：返回指定对象的原始值<br>语法：object.valueOf()<br>参数：无<br>返回值：该对象的原始值<br>是否改变原对象：false<br>兼容性：all<br>版本：ES1<br>描述：</p>
<pre><code>var obj = {
    fn: function(){
        console.log(1);
    }
}

var a = obj.valueOf();

console.log(obj); //Object {}
console.log(a);   //Object {}

console.log(obj === a);  //true

//覆盖自定义对象的 valueOf 方法
function myNumberType(n) {
this.number = n;
}
myNumberType.prototype.valueOf = function() {
    return this.number;
};
myObj = new myNumberType(4);
myObj + 3; // 7
</code></pre><h1 id="29-Object-prototype-watch-————unstandard"><a href="#29-Object-prototype-watch-————unstandard" class="headerlink" title="29. Object.prototype.watch()————unstandard"></a>29. Object.prototype.watch()————unstandard</h1><p>作用：监视一个对象的某个属性是否被赋值，在该属性赋值时出发指定的回调函数<br>语法：object.watch(prop, handler)<br>参数：</p>
<ul>
<li>prop: 想要监视值是否发生变化的指定对象的某个属性的属性名称</li>
<li>handler: 当指定的属性发生变化时执行的回调函数</li>
</ul>
<p>返回值：—<br>是否改变原对象：true<br>兼容性：所有支持ES5的浏览器<br>版本：—<br>描述： 通常来讲,你应该尽量避免使用 watch()和 unwatch() 方法 . 这两个方法仅在Gecko中实现,并且它们主要是为了在调试的时候使用</p>
<pre><code>var o = {p:1};
o.watch(&quot;p&quot;,
  function (id, oldval, newval) {
    console.log(&quot;o.&quot; + id + &quot;由&quot; + oldval + &quot; 变为 &quot; + newval);
    return newval;
  });

o.p = 2; //o.p 由 1 变为 2
o.p = 3; //o.p 由 2 变为 3
delete o.p;
o.p = 4; //o.p 由 undefined 变为 4

o.unwatch(&apos;p&apos;);
o.p = 5;
</code></pre><h1 id="30-Object-seal"><a href="#30-Object-seal" class="headerlink" title="30. Object.seal()"></a>30. Object.seal()</h1><p>作用：让一个对象密封，并返回被密封后的对象。密封对象将会阻止向对象添加新的属性，并且会将所有已有属性的可配置性（configurable）置为不可配置（false），即不可修改属性的描述或删除属性。但是可写性描述（writable）为可写（true）的属性的值仍然被修改。<br>语法：Object.seal(obj)<br>参数：obj: 将要被密封的对象<br>返回值：被密封后的对象<br>是否改变原对象：true<br>兼容性：IE9+ ,opere-<br>版本：ES5<br>描述：通常情况下，一个对象是可扩展的（可以添加新的属性）。密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置。属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。但属性的值仍然可以修改。尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出TypeError 异常（严格模式）。</p>
<p>不会影响从原型链上继承的属性。但 <strong>proto</strong> (  ) 属性的值也会不能修改。</p>
<pre><code>var obj = {
    name: &apos;zhangqi&apos;,
    age: 29
};

var a = Object.seal(obj);
obj.name = &quot;zhaojinge&quot;;
obj.job = &quot;web&quot;;
console.log(obj); //Object {name: &quot;zhaojinge&quot;, age: 29}
</code></pre><h1 id="31-Object-setPrototypeOf"><a href="#31-Object-setPrototypeOf" class="headerlink" title="31. Object.setPrototypeOf()"></a>31. Object.setPrototypeOf()</h1><p>作用：设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  null。<br>语法：Object.setPrototypeOf(obj, prototype)<br>参数：</p>
<ul>
<li>obj: 要设置其原型的对象</li>
<li>prototype: 该对象的新原型(obj || null)</li>
</ul>
<p>返回值：obj<br>是否改变原对象：true<br>兼容性：IE11+ ,safari-<br>版本：ES6<br>描述：如果对象的[[Prototype]]被修改成不可扩展(通过 Object.isExtensible()查看)，就会抛出 TypeError异常。如果prototype参数不是一个对象或者null(例如，数字，字符串，boolean，或者 undefined)，则什么都不做。否则，该方法将obj的[[Prototype]]修改为新的值。</p>
<pre><code>function fn(){}
fn.prototype = {
    getName: function(){
        console.log(&apos;zhangqi&apos;);
    }
}
function newfn(){}
var a = new newfn();

var b = Object.setPrototypeOf(a, fn.prototype);
console.log(b); //newfn {}
a.getName(); //zhangqi
console.log(b === a);//true
</code></pre><h1 id="32-Object-values"><a href="#32-Object-values" class="headerlink" title="32. Object.values()"></a>32. Object.values()</h1><p>作用：返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同 ( 区别在于for-in循环枚举原型链中的属性 )<br>语法：Object.values(obj)<br>参数：obj: 被返回可枚举属性值的对象<br>返回值：数组<br>是否改变原对象：false<br>兼容性：firefox<br>版本：ES7<br>描述：</p>
<pre><code>var obj = { foo: &quot;bar&quot;, baz: 42 };
console.log(Object.values(obj)); // [&apos;bar&apos;, 42]

var obj = { 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; };
console.log(Object.values(obj)); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]

var an_obj = { 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; };
console.log(Object.values(an_obj)); // [&apos;b&apos;, &apos;c&apos;, &apos;a&apos;]

var my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });
my_obj.foo = &quot;bar&quot;;
console.log(Object.values(my_obj)); // [&apos;bar&apos;]

console.log(Object.values(&quot;foo&quot;)); // [&apos;f&apos;, &apos;o&apos;, &apos;o&apos;]
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Godzhang" />
          <p class="site-author-name" itemprop="name">Godzhang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Godzhang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
